<section xmlns="http://www.w3.org/1999/xhtml" data-type="chapter" id="ch_introduction">
<h1>Introduction</h1>


<p class="lead">In this chapter, I present the main concepts of messaging protocols.
To illustrate their use on mobile and Web platforms, we will write two applications (one for each messaging protocol that are described, STOMP and MQTT). This chapter will present the overal design of these two applications that will be written in the subsequent chapters.</p>






<section data-type="sect1" id="_messaging_concepts">
<h1>Messaging Concepts</h1>

<p>In the preface, I introduced messaging protocols in two sentences and five concepts:</p>
<ul>
<li>
<p>An application <em>produces</em> a <em>message</em> to a <em>destination</em> on a <em>broker</em>.</p>
</li>
<li>
<p>An application subscribes to this same destination to <em>consume</em> the message.</p>
</li>
</ul>

<p>Let’s now define these five concepts:</p>
<ol>
<li>
<p>A <em>message</em> is the data exchanged between applications</p>
</li>
<li>
<p>A <em>destination</em> is a type of address that is used to exchange messages</p>
</li>
<li>
<p>A <em>producer</em> is an application that sends <em>messages</em> <strong>to</strong> a <em>destination</em></p>
</li>
<li>
<p>A <em>consumer</em> is an application that consumes <em>messages</em> <strong>from</strong> a <em>destination</em></p>
</li>
<li>
<p>A <em>broker</em> is the server entity that will handle messages from producers and deliver them to the consumers according to their destinations.</p>
</li>

</ol>

<figure id="img_preface_messaging_concepts">
<img src="images/mawm_0101.png" alt="Diagram of the messaging concepts"/>
<figcaption>Messaging Concepts</figcaption>
</figure>

<p>The simplicity of messaging can be deceiving but it is this simplicity that allows to use it in powerful ways.</p>
<div data-type="note">
<h1>Messaging Terminology</h1>

<p>Depending on the messaging protocol or model, the <em>producer</em> is sometimes called <em>sender</em> or <em>publisher</em>. Likewise, the <em>consumer</em> may be called <em>receiver</em> or <em>subscriber</em>.</p>

<p>In this book, I will always use the general terms of <em>producer</em> and <em>consumer</em>.</p>

</div>

<p>One key aspect of messaging is that it loosely couples its participants. The producer and consumer know nothing of each other. When one application produces a message, it has no knowledge on when or where the message will be consumed.
There may be one or many consumers that will receive the message. It also possible that the message will not be consumed at all if nobody has registered any interest for it.</p>

<p>Likewise, when an application consumes a message, it does not know which application sent it as they never communicate directly. The consumed message could contain enough information to identify the application but that is not required (and more often than not, it is not necessary).</p>

<p>Producers and consumers do not even need to be online at the same time. The producers can send a message and exit. The message will be held by the broker until a consumer subscribes to the same destination. At that moment, the broker will deliver the message to the consumer.</p>

<p>Producers and consumers need to know about the broker to connect to it but they may even not connect to the same broker. A set of brokers can constitute a cluster and messages would flow from one to another before they are finally delivered to a consumer.</p>
</section>













<section data-type="sect1" id="_messaging_models">
<h1>Messaging Models</h1>

<p>A messaging model describes how the messages will be routed between the producer and consumers.</p>

<p>There are two main messaging models:</p>
<ul>
<li>
<p>Point-to-Point</p>
</li>
<li>
<p>Publish/Subscribe</p>
</li>
</ul>








<section data-type="sect2" id="_point_to_point">
<h2>Point-to-Point</h2>

<p>In a Point-to-Point messaging model, a message sent by a producer will be routed to a single consumer.</p>

<p>The producer sends a message to a destination identified as a <em>queue</em> in that messaging model. There can be zero, one or many consumers subscribed (or <em>bound</em>) to this queue and the messaging broker will route incoming messages to only one of these consumers to deliver the message.
As illustrated in <a data-type="xref" href="#img_intro_point_to_point">#img_intro_point_to_point</a>, when the producer sends a message to the queue, only one of the consumers that are subscribed receives the message.</p>

<figure id="img_intro_point_to_point">
<img src="images/mawm_0102.png" alt="Diagram of the Point-to-Point Topology"/>
<figcaption>Diagram of the Point-to-Point Topology</figcaption>
</figure>

<p>This messaging model is also called <em>one-to-one</em>: for <em>one</em> message sent by a producer to the queue, there is only <em>one</em> consumer that will receive it.</p>

<p>If there are no consumers bound to the queue, the broker will retain the incoming messages until a consumer subscribes and then deliver the message to this consumer.
Some messaging brokers allow to <em>expire</em> messages if they remain in the queue for a certain amount of time. This can be useful to avoid having consumers receive a message corresponding to stale data.</p>

<p>The Point-to-point model is best used when only one consumer must process a message. A queue can be used to load-balance the message processing across different clients and ensure that only one client will receive it.</p>
</section>













<section data-type="sect2" id="_publish_subscribe">
<h2>Publish/Subscribe</h2>

<p>In a Publish/Subscribe messaging model (often shortened as pub/sub), a message sent by a producer is routed to many consumers.</p>

<p>The producer sends a message to a destination identified as a <em>topic</em> in that messaging model. There can be zero or many consumers subscribed to this topic and the messaging broker will route incoming message to <em>all</em> these consumers to deliver the message. If there are no consumers bound to the topic, the broker may <em>not</em> retain the incoming messages.
As illustrated in <a data-type="xref" href="#img_intro_pub_sub">#img_intro_pub_sub</a>, when the producer sends a message to the topic, all the consumers that are subscribed receive the message.</p>

<figure id="img_intro_pub_sub">
<img src="images/mawm_0103.png" alt="Diagram of the Point-to-Point Topology"/>
<figcaption>Diagram of the Publish/Subscribe Topology</figcaption>
</figure>

<p>This messaging model is also called <em>one-to-many</em>: for <em>one</em> message sent by a producer to a topic, there are <em>many</em> consumers that may receive it.</p>

<p>When a message is sent to a topic in this model, we often say that it is <em>broadcasted</em> to all consumers as they will all receive it.</p>

<p>Some protocols define the notion of <em>durable subscribers</em>. If a consumer subscribes to the topic as a durable subscriber, the broker will retain messages when the consumer is offline and deliver the messages sent to the topic during its downtime when the consumer comes online again.</p>

<p>The Publish/Subscribe model is particularly suited to send updates. A producer will send a message on the topic with its updated data and any consumer that is subscribed to the topic will be notified of the updates.</p>
</section>





</section>













<section data-type="sect1" id="_message_representation">
<h1>Message Representation</h1>

<p>Producers and consumers exchange information using messages.</p>

<p>A message is composed of three separate data: destination, headers, and body</p>

<figure id="img_intro_message_representation">
<img src="images/mawm_0104.png" alt="Diagram of a Message"/>
<figcaption>Diagram of a Message</figcaption>
</figure>

<p>When a producer sends a message to a <em>destination</em>, the name of the destination is put inside the message. When a consumer receives this message, it can use this information to know which destination held this message. This is especially useful when a consumer is subscribes to many destinations as it helps identify the exchanged data.</p>

<p>A message may also contain <em>headers</em>. Messaging protocols uses headers to add metadata information to the messages. These metadata can be read by the consumers and give addition contextual information to a message. Examples of such metadata are message identifiers (that uniquely identify a message for a broker), timestamp (the date and time it was sent by the producer), redelivered flag (if the message was delivered unsuccessfully a first time and is delivered again), etc.
Headers are specific to messaging protocols. Some messaging protocols (such as STOMP) allows the producer to set application-specific headers in addition to the headers defined by the protocol. Other protocols (such as MQTT) does not allow to set application-specific headers. In that case, the producer has to put any application-specific information in the message payload.</p>

<p>Finally, a message can have an optional <em>body</em> (or payload) that contains the data exchanged between the producer and consumer. The type of body depends on the messaging protocols, some defining text payload (such as STOMP) or binary (MQTT). A payload is an <em>opaque blob of content</em>. The broker do not read or modify it when it routes a message.</p>

<p>In most cases, we will only use the message body to pass information using a variety of format (JSON string, simple plain string, array of float values, etc.). However if the protocol permits it, we will also set additional headers to the message to give metadata information about the body (its content type, its length, etc.) or activate some broker features.</p>
</section>













<section data-type="sect1" id="_examples">
<h1>Examples</h1>

<p>To illustrate the use of messaging protocols on mobile and Web platforms, we will build two set of applications in this book. Each set will be be composed of an iOS application and a web one. The first application will use STOMP and the second one MQTT.</p>








<section data-type="sect2" id="ch_introduction_stomp_example">
<h2>Locations Application Using STOMP</h2>

<p>Suppose that we work for a delivery company that uses a fleet of trucks to deliver packages to its clients.</p>

<p>Each truck is responsible for the delivery of packages and they receive orders from their headquarters. To efficiently manage all the trucks, the company headquarter want to monitor the truck’s positions and be able to send them orders on-the-go.</p>

<p>We will build a very simple application named <code>Locations</code> that looks similar to this example.</p>

<p>The "truck" will use an iOS application to broadcast the device’s geolocation data using its GPS sensor and display text messages that it receives from the headquarters. The "headquarter" will use a Web application to display the locations of all the "trucks" on a map. It will also be used to send text messages to a given truck on their devices:</p>
<ol>
<li>
<p>In <a data-type="xref" href="#ch_mobile_stomp">#ch_mobile_stomp</a>, we will write the <code>Locations</code> iOS application using the STOMP protocol to send GPS data and receive text from an iOS device.</p>
</li>
<li>
<p>In <a data-type="xref" href="#ch_web_stomp">#ch_web_stomp</a>, we will write the Web application using STOMP protocol over Web Sockets to receive GPS data in a Web browser and send text to the devices.</p>
</li>

</ol>

<figure id="img_example_app_1">
<img src="images/mawm_0105.png" alt="Diagram of the Locations application with two devices, AAA and BBB, and two web applications"/>
<figcaption>Diagram of the Locations application with two devices, AAA and BBB, and two web applications.</figcaption>
</figure>

<p>Before introducing STOMP, the messaging protocol that will be used by the application, we can already define the application’s messaging models and how the different parts of the application will exchange messages.</p>










<section data-type="sect3" id="ch_introduction_stomp_example_topology">
<h3>Locations Messaging Models</h3>

<p>In this application, we will use two destinations, one with a Publish/Subscribe model to broadcast the device GPS data and one with a Point-to-Point model for the text messages:</p>
<ul>
<li>
<p><code>device.XXX.location</code> is the <em>topic</em> to broadcast its GPS geolocation data where <code>XXX</code> is the device identifier (Publish/Subscribe model)</p>
</li>
<li>
<p><code>device.XXX.text</code> is the <em>queue</em> to receive simple text message  (Point-to-Point model)</p>
</li>
</ul>

<p>A topic is used to send the GPS data as this allows potentially many consumers to receive the information.
However a queue is used to handle the device’s text as only one single device will consume messages from this destination.</p>

<p>Each device (identified by an unique identifier <code>XXX</code>) running the <code>Locations</code> application will be:</p>
<ul>
<li>
<p>a <em>producer</em> of messages to the topic <code>device.XXX.location</code></p>
</li>
<li>
<p>the only <em>consumer</em> of messages from the queue <code>device.XXX.text</code></p>
</li>
</ul>

<p>Conversely, the Web application will be:</p>
<ul>
<li>
<p>a <em>consumer</em> of messages from <em>all</em> the topics of the form <code>device.XXX.location</code></p>
</li>
<li>
<p>a <em>producer</em> of message to <em>all</em> the queues of the form <code>device.XXX.text</code></p>
</li>
</ul>
</section>













<section data-type="sect3" id="ch_introduction_stomp_example_message">
<h3>Locations Message Representation</h3>

<p>There will be two types of exchanged messages:</p>
<ul>
<li>
<p>one to represent GPS data (exhanged on the topics <code>device.XXX.location</code>)</p>
</li>
<li>
<p>one to represent orders (exchanged on the queues <code>device.XXX.text</code>)</p>
</li>
</ul>

<p>The <code>Locations</code> iOS application will send the GPS data using a JSON representation in the message payload:</p>
<div id="ex_example_gps_data" data-type="example">
<h5>Geolocation Message Payload</h5>


<pre data-type="programlisting">{
  "deviceID": "BBB",<a class="co" id="co_ch1-co-1" href="#callout_ch1-co-1"><img src="images/callouts/1.png" alt="1"/>#callout_ch1-co-1</a>
  "lat": 48.8581,<a class="co" id="co_ch1-co-2" href="#callout_ch1-co-2"><img src="images/callouts/2.png" alt="2"/>#callout_ch1-co-2</a>
  "lng": 2.2946,<a class="co" id="co_ch1-co-3" href="#callout_ch1-co-3"><img src="images/callouts/3.png" alt="3"/>#callout_ch1-co-3</a>
  "ts": "2013-09-23T08:43Z"<a class="co" id="co_ch1-co-4" href="#callout_ch1-co-4"><img src="images/callouts/4.png" alt="4"/>#callout_ch1-co-4</a>
}</pre>

<dl class="calloutlist">
<dt><a class="co" id="callout_ch1-co-1" href="#co_ch1-co-1"><img src="images/callouts/1.png" alt="1"/>#co_ch1-co-1</a></dt><dd><p><code>deviceID</code> is the identifier of the device that sends its position</p></dd>
<dt><a class="co" id="callout_ch1-co-2" href="#co_ch1-co-2"><img src="images/callouts/2.png" alt="2"/>#co_ch1-co-2</a></dt><dd><p><code>lat</code> is a number representing the position’s <em>latitude</em></p></dd>
<dt><a class="co" id="callout_ch1-co-3" href="#co_ch1-co-3"><img src="images/callouts/3.png" alt="3"/>#co_ch1-co-3</a></dt><dd><p><code>lng</code> is a number representing the position’s <em>longitude</em></p></dd>
<dt><a class="co" id="callout_ch1-co-4" href="#co_ch1-co-4"><img src="images/callouts/4.png" alt="4"/>#co_ch1-co-4</a></dt><dd><p><code>ts</code> is a string representing the time when the position was taken (using the <a href="http://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> format)</p></dd>
</dl>

</div>

<p>The text messages that will be consumed by the <code>Locations</code> iOS application will
be represented as a simple plain text string.</p>
<div id="ex_example_text" data-type="example">
<h5>Text Message Payload</h5>


<pre data-type="programlisting">"Where are you heading to?"</pre>
</div>

<p>A more realistic representation of this message would also contain additional information such the identifier of the headquarter sending the message, etc.
We are using a plain text version as this format is enough to provide a first version.</p>

<p>With the messaging topology and data representation known, we can now refine the <code>Locations</code> application diagram.</p>

<figure id="img_example_app_2">
<img src="images/mawm_0106.png" alt="Diagram of the Locations application"/>
<figcaption>Diagram of the Locations application with its messaging models and representations</figcaption>
</figure>
</section>



</section>













<section data-type="sect2" id="ch_introduction_mqtt_example">
<h2>Motions Application Using MQTT</h2>

<p>Most mobile devices contain sensor that allows to track the device motions (and to a certain extent the motion of its owner). Using additional sensors, we could even imagine having access to the owner’s health data (heart rate, hydration, blood glucose level, etc.). This type of information could be sent to a centralized application that would be able to track the data and extract personal information about them to report to the owner.</p>

<p>We will write a simple application, <code>Motions</code> that follows this model to illustrate the use of MQTT protocol. The iOS application will track the device motion and change its background color to "alert" its user when an alert message is received.</p>

<p>Device motion will be represented by three values corresponding to its pitch, roll and yaw values as shown in the illustration below.</p>

<figure id="img_mqtt_example_app_0">
<img src="images/mawm_0107.png" alt="The pitch, roll and yaw values represents the device motion"/>
<figcaption>The pitch, roll and yaw values represents the device motion.</figcaption>
</figure>

<p>The pending Web application will display the motions of all devices that broadcast them and be able to send alert messages to them:</p>
<ol>
<li>
<p>In <a data-type="xref" href="#ch_mobile_mqtt">#ch_mobile_mqtt</a>, we will write the <code>Motions</code> iOS application using the MQTT protocol to send data about the device motions and receive alerts.</p>
</li>
<li>
<p>In <a data-type="xref" href="#ch_web_mqtt">#ch_web_mqtt</a>, we will write a Web application using MQTT protocol over Web Sockets to receive all the device motions data and display them. The Web application will also be able to send alert messages to any devices sending its motions data.</p>
</li>

</ol>

<figure id="img_mqtt_example_app_1">
<img src="images/mawm_0108.png" alt="Diagram of the +Motions+ application"/>
<figcaption>The Motions application with two clients, AAA and BBB and two Web applications monitoring them.</figcaption>
</figure>










<section data-type="sect3" id="ch_introduction_mqtt_example_topology">
<h3>Motions Messaging Models</h3>

<p>In this application we will use two destination with the Publish/Subscribe model:</p>
<ul>
<li>
<p><code>/mwm/XXX/motion</code> (where <code>XXX</code> is the device identifier) is the topic to broadcast the device motion data (Publish/Subscribe model)</p>
</li>
<li>
<p><code>/mwm/XXX/alert</code> is the topic to exchange alert messages for a given device (Publish/Subscribe model)</p>
</li>
</ul>

<p>Each device running the <code>Motions</code> application will be:</p>
<ul>
<li>
<p>a <em>producer</em> of messages to the topic <code>/mwm/XXX/motion</code></p>
</li>
<li>
<p>a <em>consumer</em> of messages from the topic <code>/mwm/XXX/alert</code></p>
</li>
</ul>

<p>Conversely, the Web application will be:</p>
<ul>
<li>
<p>a <em>consumer</em> of messages from all the topics of the form <code>/mwm/XXX/motion</code></p>
</li>
<li>
<p>a <em>producer</em> of message to all the topics of the form <code>/mwm/XXX/alert</code></p>
</li>
</ul>
<div data-type="note">


<p>MQTT only supports the <em>Publish/Subscribe</em> messaging model. Ideally, the alert destination would be better modeled as a queue (one per device). Since MQTT does not have support for queues, we will work around that by using one topic for each device and only have the corresponding device subscribes to it.</p>

</div>
</section>













<section data-type="sect3" id="ch_introduction_mqtt_example_message">
<h3>Motions Message Representation</h3>

<p>There will be two types of exchanged messages:</p>
<ul>
<li>
<p>one to represent device motion data (exhanged on the topics <code>/mwm/XXX/motion</code>)</p>
</li>
<li>
<p>one to represent alerts (exchanged on the topics <code>/mwm/XXX/alert</code>)</p>
</li>
</ul>

<p>The <code>Motions</code> iOS application will send the device motions data in a binary message where its payload will be composed of three 64-bit floats representing the device’s pitch, roll and yaw values.</p>
<div id="ex_example_motion_data" data-type="example">
<h5>Device Motion Message Paylaod</h5>


<pre data-type="programlisting">&lt;&lt; 1.6 -0.1 0.8 &gt;&gt; <a class="co" id="co_ch1-co-5" href="#callout_ch1-co-5"><img src="images/callouts/1.png" alt="1"/>#callout_ch1-co-5</a>
</pre>

<dl class="calloutlist">
<dt><a class="co" id="callout_ch1-co-5" href="#co_ch1-co-5"><img src="images/callouts/1.png" alt="1"/>#co_ch1-co-5</a></dt><dd><p>The message is composed of three 64-bit floats for the <code>pitch</code>, <code>roll</code>, and <code>yaw</code> values</p></dd>
</dl>
</div>

<p>The alert messages that will be consumed by the <code>Motions</code> iOS application will
be represented as a simple plain text string corresponding to a color. The <code>Motions</code> application will use this payload to change temporarily its background color to <em>alert</em> the user.</p>
<div id="ex_example_alert_data" data-type="example">
<h5>Alert Message Payload</h5>


<pre data-type="programlisting">"red" <a class="co" id="co_ch1-co-6" href="#callout_ch1-co-6"><img src="images/callouts/1.png" alt="1"/>#callout_ch1-co-6</a></pre>

<dl class="calloutlist">
<dt><a class="co" id="callout_ch1-co-6" href="#co_ch1-co-6"><img src="images/callouts/1.png" alt="1"/>#co_ch1-co-6</a></dt><dd><p>The message is composed of a string containing the name of a simple color.</p></dd>
</dl>
</div>

<p>With the messaging topology and data representation known, we can now refine the <code>Motions</code> application diagram.</p>

<figure id="img_mqtt_example_app_2">
<img src="images/mawm_0109.png" alt="Diagram of the Motions application"/>
<figcaption>Diagram of the Motions application with its messaging models and representations.</figcaption>
</figure>
</section>



</section>





</section>













<section data-type="sect1" id="_summary">
<h1>Summary</h1>

<p>In this chapter, we learnt about the messaging protocols and how they differ from request/reply protocols. We introduced two messaging models - <em>Point-to-Point</em> and <em>Publish/Subscribe</em> - and the parts that compose a message - <em>destination</em>, <em>headers</em>, and <em>payload</em>.</p>

<p>We have also described the two applications with their messaging models and representation that will be written in the subsequent chapters: the <code>Locations</code> application that uses STOMP and the <code>Motions</code> applications that uses MQTT.</p>

<p>In the next chapter, we will start writing the <code>Locations</code> application running on iOS devices. If you are more interested by learning about MQTT, you can go directly to <a data-type="xref" href="#ch_mobile_mqtt">#ch_mobile_mqtt</a> to start writing the <code>Motions</code> application.</p>
</section>







</section>
