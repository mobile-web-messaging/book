[[ch_mobile_stomp]]
== Mobile Messaging With STOMP

[role="lead"]
In this chapter, we will present the STOMP messaging protocool and write our first messaging client: an native application running on an iPhone.
We will use STOMP to send and receive messages using the Objective-C library StompKit.

In <<ch_introduction_stomp_example>>, we describe the +Locations+ applications. In this chapter, we will write its iOS application that will broadcast the GPS position and receive text message.

[[img_mobile_stomp_1]]
.Diagram of the +Locations+ iOS application
image::images/Chapter020/stomp_ios_app.png["Diagram of the Locations iOS application"]

=== About the Code

All along the chapter, we will show all the code required to run the application.

The whole application code can be retrieved from the https://github.com/mobile-web-messaging/code[GitHub repository] in the +stomp/ios/+ directory.

=== STOMP

For the next four chapters, we will use the STOMP protocol to build our applications.

This book covers the latest released version of the protocol at the time of this writing: STOMP 1.2 <<stomp1.2>>.

STOMP is a simple text-based messaging protocol that is well suited to build lightweight messaging applications on any platforms. It provides an interoperable wire format so that any client can communicate with any message broker.
The simplicity of the protocol ensures that it is straightforward to have interoperability between client and brokers.

STOMP does not define the semantic of the destination, they depend on the STOMP broker you are using.

There are some conventions shared by STOMP brokers (for example, prefixing a destination by +/queue/+ to use a queue and by +/topic/+ to use a topic) but you need to consult your broker documentation to check which messaging model are supported (including _Point-to-Point_ and _Publish/Subscribe_) and how to use them.

.Install and configure a messaging broker
[NOTE]
====
Before using a STOMP client, a broker must be installed and
configured to be able to exchange messages.

In this book, we use Apache ActiveMQ as the messaging broker. The <<appendix_activemq>> shows how to install and configure ActiveMQ.

Once ActiveMQ is started, it will accept STOMP connections on the +61613+ port.
====

=== StompKit

To use STOMP on iOS, we will use the +StompKit+ Objective-C library that implements the STOMP protocol in a modern event-driven way using ARC, Grand Central Dispatch and blocks.

The source code of this library project is hosted on https://github.com/mobile-web-messaging/StompKit/[GitHub].

=== Create the +Locations+ Project With Xcode

We will use https://developer.apple.com/xcode/[Xcode] to create the +TruckTracker+ application.

Once Xcode is installed and started, we create a new project from its launch screen:

[[img_mobile_stomp_1]]
.Select +Create a new Xcode project+ from Xcode launch screen.
image::images/Chapter020/xcode_launch_screen.png["XCode Launch screen"]

The application consists in a single view so we choose the **`Single View Application`** template in +iOs > Application+ from the template screen.

[[img_mobile_stomp_2]]
.Select +Single View Application+ from the template screen
image::images/Chapter020/template_screen.png["XCode template screen"]

We will call the project +Locations+ and select to build it only for iPhone devices.

[[img_mobile_stomp_3]]
.XCode project options screen
image::images/Chapter020/project_options_screen.png["XCode project options screen"]

Finally we will save it in a folder on our machine.

=== Create the Podfile

To import the library that we will use to send and receive messages, we will setup the project to use http://cocoapods.org[CocoaPods], an Objective-C Library Manager.

First we need to close Xcode because we will modify the project structure to import our dependencies.

After installing CocoaPods by following the instructions on its web site, we create a file at the root of the project (in the same directory than +Locations.xcodeproj+) named **`Podfile`**.

[[ex_mobile_stomp_1]]
.+Locations+' Podfile
====
----
xcodeproj 'Locations.xcodeproj'

pod 'StompKit', '~> 0.1'

platform :ios, '5.0'
----
====

After saving this file, run the **`pod install`** command.

[[ex_mobile_stomp_2]]
.Install +Locations+ dependencies
====
----
$ pod install
Analyzing dependencies
Downloading dependencies
Installing CocoaAsyncSocket (7.3.2)
Installing StompKit (0.1.0)
Generating Pods project
Integrating client project

[!] From now on use `Locations.xcworkspace`.
----
====

We can now open again Xcode but we must do it using the _Workspace_ file named +Locations.xcworkspace+, and not the _Project_ file named +Locations.xcodeproj+.

[[img_mobile_stomp_4]]
.Open the Workspace file
image::images/Chapter020/open_worskpace.png["Open the Workspace file"]

First, we will verify that the project is setup correctly and that the application can run in the iOS simulator.

We will simulate the latest iPhone devices by selecting +Product > Destination > iPhone Retina (4-inch 64-bit)+ from Xcode menu bar.
If we run the application by selecting **`Product`** > **`Run`** (or pressing **`⌘R`**), the iOS simulator starts and opens the application which is composed of a blank view.

[[img_mobile_stomp_5]]
.+Locations+ Blank View
image::images/Chapter020/blank_view.png["Locations Blank View"]

Nothing is displayed but it confirms that the project and its dependencies are  successfully compiled and launched.

=== Identify The Device

The iPhone device is will broadcast its position. The first thing to do is identify the device. To keep the example simple, we will use a _universal unique identifier_ (or UUID) as the device identifier and display it in the view.

Since the application will run only on iPhone devices, all the user interface will be setup in the **`Main.storyboard`** file.

Click on **`Main.storyboard`** to open it. From the +Object+ library, drag a +Label+ on the +View+'s window. Place it at the top of the view and change the text to +Device ID+.

[[img_mobile_stomp_6]]
.Add the Device ID label.
image::images/Chapter020/deviceID_label.png[Add the Device ID label]

.Interface Layout Constraints
[NOTE]
====
I will not describe into details how to set up the layout constraints for the graphical objects so that they adapt correctly to the device's size and orientation.

However the example code in the https://github.com/mobile-web-messaging/code[GitHib repository] is constrained correctly.
====

The UUID that we will generate is quite long so we will change its appearance by setting its +Font+ +System 13.0+ and its +Alignment+ to centered to fit the screen.

[[img_mobile_stomp_7]]
.Change the appearance of the device ID label.
image::images/Chapter020/deviceID_label_options.png[Change the appearance of the device ID label]

We will connect this label to the +MWMViewController+ object.

Add the necessary outlet property in +MWMViewController.m+ and a +NSString+ to hold the identifier.

[source,objc]
----
@interface MWMViewController ()

@property (weak, nonatomic) IBOutlet UILabel *deviceIDLabel;

@property (copy, nonatomic) NSString *deviceID;

@end
----

Open the +Main.storyboard+ and control-click on +View Controller+ to see its connection panel. Drag from +deviceIDLabel+ to the +UILabel+ to connect it.

[[img_mobile_stomp_8]]
.Connect the +deviceIDLabel+ outlet property to the device ID +UILabel+.
image::images/Chapter020/deviceIDLabel_connection.png[Connect the deviceIDLabel outlet property to the device ID UILabel]

Now that the outlet property is connected to the label, we need to generate a UUUID for the application and display it when the view appears.

Open the +MWMViewController.m+ file to add code to the +MWMViewController+ _implementation_. When the application starts and the view is loaded in +viewDidLoad+, we set the +deviceID+ using a UUID.

[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);
}
----

.About Unique Identifier
[NOTE]
====
The +identifierForVendor+ property will uniquely identify the device for the application's vendor (that we set to +net.mobile-web-messaging+ when we created the project).
====

We also need to set the label to this ID when the view will appear.

[source,objc]
----
- (void)viewWillAppear:(BOOL)animated
{
    self.deviceIDLabel.text = self.deviceID;
}
----

If we run the application, we will see the device ID displayed instead of +Device ID+ in the view.

[[img_mobile_stomp_9]]
.Display the device ID.
image::images/Chapter020/view_with_deviceID.png[Display the device ID]

Now that we have the identifier of the device, the next step is to retrieve its geolocation data using the +CoreLocation+ framework before we can send them in a STOMP message.

[NOTE]
====
The next sections deal with setting up the framework and writing code to retrieve the GPS data from the device and display them. This is unrelated to messaging and you can skip them if you only want to read how to send and receive messages. Still, we thought the messaging code would be more meaningful if it was using real data instead of generating random dummy data. By using GPS data instead, we will be able to build a mobile app that display these data on a map in the next chapter.
====

[[ch_mobile_stomp_display_position]]
=== Display the Device Position

We will retrieve the geolocation data from the device's GPS sensor to send them using STOMP messages. However, we also want to have some graphical feedback to show that the data changes over the time as we move with our device.

To display the geolocation data, we will add a +UILabel+ to the view and change its text to +Current position: ???+

[[img_mobile_stomp_10]]
.Add the current position label
image::images/Chapter020/currentPosition_label.png[Add the current position label]

We will change its appearance to match the +deviceID+ label by setting its +Font+ to +System 13.0+ and its +Alignment+ to centered.

[[img_mobile_stomp_11]]
.Change the appearance of the current position label.
image::images/Chapter020/currentPosition_label_options.png[Change the current position label appearance]

Open the +MWMViewController.m+ file and add a property to the +MWMViewController+ _interface.

[source,objc]
----
@property (weak, nonatomic) IBOutlet UILabel *currentPositionLabel;
----

We then bind this property to the label. Open the +Main.storyboard+ and control-click on +View Controller+ to see its connection panel. Drag from +currentPositionLabel+ to the label to connect it.

[[img_mobile_stomp_12]]
.Connect the +currentPositionLabel+ outlet property to the current position +UILabel+.
image::images/Chapter020/currentPositionLabel_connection.png[Connect the currentPositionLabel outlet property to the current position UILabel]

The label is now connected to the property. The next step is to retrieve the geolocation data from the device to update this property and send a STOMP message with them.

=== Access the Device Geolocation Data with +CoreLocation+ Framework

iOS provides the +CoreLocation+ framework to access the location data.

We need to add it to the libraries linked by the app. Click on the +Locations+ project and then the +Locations+ target. In the +General+ tab, under the +Linked Frameworks and Libraries+ section, click on the +++ button. In the selection window, type **`CoreLocation`**, select the +CoreLocation.framework+ and click on the +Add+ button.

[[img_mobile_stomp_13]]
.Add the CoreLocation framework.
image::images/Chapter020/CoreLocation_framework.png["Add the CoreLocation framework"]

We can now use the +CoreLocation+ framework by importing +<CoreLocation/CoreLocation.h>+ at the top of the +MWMViewController.m+ file.

We will make the +MWMViewController+ interface conform to the +CLLocationManagerDelegate+ protocol and declare a +CLLocationManager+ property named +locationManager+.

[source,objc]
----
#import <CoreLocation/CoreLocation.h>

interface MWMViewController () <CLLocationManagerDelegate>

@property (strong, nonatomic) CLLocationManager *locationManager;

@end
----

We will define two methods to start and stop updating the current location. When the apps starts updating the current location in +startUpdatingCurrentLocation+, it creates the +locationManager+ if it's not already created and designates the controller as the locationManager's +delegate+. We will also Since the geolocation data will be used to follow the device as it moves, we set the locationManagere's +desiredAccuracy+ to +kCLLocationAccuracyBestForNavigation+.

Finally, the application will start listening for the device location by calling locationManager's +startUpdatingLocation+ method.

====
[source,objc]
----
#pragma mark - CoreLocation actions

- (void)startUpdatingCurrentLocation
{
    NSLog(@"startUpdatingCurrentLocation");

    // if location services are restricted do nothing
    if ([CLLocationManager authorizationStatus] == kCLAuthorizationStatusDenied ||
        [CLLocationManager authorizationStatus] == kCLAuthorizationStatusRestricted) {
        return;
    }

    // if locationManager does not currently exist, create it
    if (!self.locationManager) {
        self.locationManager = [[CLLocationManager alloc] init];
        // set its delegate to self
        self.locationManager.delegate = self;
        // use the accuracy best suite for navigation
        self.locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation;
    }

    // start updating the location
    [self.locationManager startUpdatingLocation];
}
----
====

To stop receiving the device location in +stopUpdatingCurrentLocation+, we simply call locationManager's +stopUpdatingLocation+ method.

====
[source,objc]
----
- (void)stopUpdatingCurrentLocation
{
    [self.locationManager stopUpdatingLocation];
}
----
====

The location of the device will be received by the designated +CLLocationManagerDelegate+ (in our case, the +MWMViewController+ implementation itself). We need to implement the +locationManager:didUpdateToLocation:fromLocation:+ method and extract the
coordinates from the +newLocation+'s +coordinate.

Once we have them, we can update the +currentPositionLabel+'s +text+ to display them.

====
[source,objc]
----
#pragma mark - CLLocationManagerDelegate protocol

- (void)locationManager:(CLLocationManager *)manager
    didUpdateToLocation:(CLLocation *)newLocation
           fromLocation:(CLLocation *)oldLocation
{
    // ignore if the location is older than 30s
    if (fabs([newLocation.timestamp timeIntervalSinceDate:[NSDate date]]) > 30) {
        return;
    }

    CLLocationCoordinate2D coord = [newLocation coordinate];
    self.currentPositionLabel.text = [NSString stringWithFormat:@"φ:%.4F, λ:%.4F", coord.latitude, coord.longitude];
}
----
====

If there are any problem with the locationManager, we want to warn the user about it and stop updating the location. To do so, we implement the +CLLocationManagerDelegate+'s +locationManager:didFailWithError:+ method to display a warning to the user:

====
[source,objc]
----
- (void)locationManager:(CLLocationManager *)manager
       didFailWithError:(NSError *)error
{
    // reset the current position label
    self.currentPositionLabel.text = @"Current position: ???";

    // show the error alert
    UIAlertView *alert = [[UIAlertView alloc] init];
    alert.title = @"Error obtaining location";
    alert.message = [error localizedDescription];
    [alert addButtonWithTitle:@"OK"];
    [alert show];
}
----
====

Now that the code related to +CoreLocation+ is in place, we just need to callthe +startUpdatingCurrentLocation+ method when the view will appear.

====
[source,objc]
----
- (void)viewWillAppear:(BOOL)animated
{
    self.truckIDLabel.text = self.truckID;

    [self startUpdatingCurrentLocation];
}

----
====

We also need to stop updating the location when the view disappears in +viewDidDisappear:+

====
[source,objc]
----
- (void)viewDidDisappear:(BOOL)animated
{
    [self stopUpdatingCurrentLocation];
}
----
====

The first time the app asks the +locationManager+ to start updating the device location, the user will see an alert view accessing him or her the permission to access the device location.

[[img_mobile_stomp_14]]
.Permission to use the current location.
image::images/Chapter020/current_location_permission.png["Permission to use the current location"]

If the user taps +OK+, the +locationManager+ will start update the device location and the label for its current position will be updated with the latitude and longitude.

[[img_mobile_stomp_15]]
.Display the current position of the device.
image::images/Chapter020/current_position.png["Display the current position of the device"]

[[ch_mobile_stomp_location_simulator]]
==== Simulate a Location With iOS Simulator

If you are running the application on an iPhone device, the real geolocation data from the device will be used.
If you run the application using the +iOS Simulator+, you can simulate different location in the +Debug > Location+ menu. For example, the +Freeway Drive+ will simulate a car driving on a freeway between Palo Alto and San Francisco.

Whether you are running the application on a device or in the simulator, you should see the +currentPositionLabel+ be udpated. The latitude and longitude numbers are difficult to interpret as such but in the next chapter <<ch_web_stomp>>, we will be able to use them to draw the position on a map to locate the devices.

Now that the +Locations+ application is handling the device geolocation data, the next step is to send them using STOMP.

=== Create a STOMP Client With +StompKit+

Before sending any messages, we must first import the +StompKit+ library that we add to the +Podfile+ file at the beginning of this chapter.

We must import its header file +StompKit.h+ at the top of the +MWMViewController.m+ file and add a +STOMPClient+ property named +client+ to the +MWMViewController+ interface.

====
[source, objc]
----
#import <StompKit.h>

@interface MWMViewController () <CLLocationManagerDelegate>

@property (nonatomic, strong) STOMPClient *client;

@end
----
====

The +client+ property will be used to communicate with the STOMP broker after it is created and connected.

We do not need to conform to any protocol to use +StompKit+ as its API is based on _blocks_ instead of protocol delegates.

The +client+ variable is created when the controller's view is loaded in +MWMViewController+'s +viewDidLoad+ method implementation. To create it, we need to pass the host and port of the STOMP broker to connect to.
These information depends on the broker you are using. If you have configured ActiveMQ on your machine as described in the appendix <<appendix_activemq>>, you will be able to connect on its +61613+ port.

The host will depend on your network configuration. On my local network, my server has the IP address +192.168.1.25+. I will use this value for the example but you will have to replace this by your own server address to run the applications.

====
[source, objc]
----
#define kHost     @"192.168.1.25"
#define kPort     61613

...

@implementation MWMViewController

- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);

    self.client = [[STOMPClient alloc] initWithHost:kHost port:kPort];
}
----
====

=== Connect to a STOMP Broker

When the +client+ object is created, it is not connected to the STOMP broker yet. To connect, we must call its +connectWitHeaders:completionHandler:+ method.

StompKit uses Grand Central Dispatch and blocks to provide an event-driven API. This means that the client is _not_ connected when the call to its +connectWitHeaders:completionHandler:+ method returns but when the completionHandler block is called.

We can pass a dictionary to +connectWitHeaders:completionHandler:+ to add aditional headers during the connection to the STOMP broker. In our application, we will send a +client-id+ header set to the +deviceID+ to uniquely identify the client against the STOMP broker.

This ensures that no two devices will be able to connect using the same identifier. Once a client is connected with a given +client-id+, any subsequent clients that uses the same value will fail to connect to the broker.

We will encapsulate this code in a +connect+ method in +MWMViewController+ implementation.

====
[source, objc]
----
@implementation MWMViewController

#pragma mark - Messaging

- (void)connect
{
    NSLog(@"Connecting...");
    [self.client connectWithHeaders:@{ @"client-id": self.deviceID}
                  completionHandler:^(STOMPFrame *connectedFrame, NSError *error) {
                      if (error) {
                          // We have not been able to connect to the broker.
                          // Let's log the error
                          NSLog(@"Error during connection: %@", error);
                      } else {
                          // we are connected to the STOMP broker without an error
                          NSLog(@"Connected");
                      }
                  }];
    // when the method returns, we can not assume that the client is connected
}

@end
----
====

We will call this +connect+ method when the view appears in +viewWillAppear:+.

====
[source, objc]
----
- (void)viewWillAppear:(BOOL)animated
{
    self.truckIDLabel.text = self.truckID;

    [self startUpdatingCurrentLocation];
    [self connect];
}
----
====

=== Disconnect From a STOMP Broker.

The +STOMPClient+ disconnects from the broker using its +disconnect:+ method. This method takes a block that will be called when the client is disconnected from the server. The block takes a +NSError+ parameter that is set if there is an error during the disconnection operation.

====
[source, objc]
----
#pragma mark - Messaging

- (void)disconnect
{
    NSLog(@"Disconnecting...");
    [self.client disconnect:^(NSError *error) {
        if (error) {
            NSLog(@"Error during disconnection: %@", error);
        } else {
            // the client is disconnected from the broker without any problem
            NSLog(@"Disconnected");
        }
    }];
    // when the method returns, we can not assume that the client is disconnected
}
----
====

We will disconnect from the broker once the view has disappeared in +viewDidDisappear:+.

====
[source, objc]
----
- (void)viewDidDisappear:(BOOL)animated
{
    [self stopUpdatingCurrentLocation];
    [self disconnect];
}
----
====

At this stage, we have an application that connect to the STOMP broker when its view is displayed and disconnect when its view disappears.

If we run the application, we see logs in Xcode that shows the connection process:

----
2014-03-13 17:07:21.667 Locations[79069:60b] Connecting...
2014-03-13 17:07:21.723 Locations[79069:3903] Connected
----

=== Send STOMP Messages

We now have a connection to the STOMP broker and we receive the device's geolocation data from the +CoreLocation+ framework. The last step to do is to send these data to the topic associated to the device ID.

As we described in <<ch_introduction_stomp_example_topology>>, each device will send its location on a topic named after its identifier.

[source,objc]
----
NSString *destination = [NSString stringWithFormat:@"/topic/device.%@.location", self.deviceID];
----

.ActiveMQ STOMP Destinations Naming Conventions
[NOTE]
====
ActiveMQ convention is to prefix a STOMP destination by +/topic/+ to use a Publish/Subscribe messaging model and by +/queue/+ to use a Point-to-Point model.

Since we designed our application to use a topic for the +device.XXX.location+, we must preprend it with +/topic/+
====

As we described in <<ch_introduction_stomp_example_message>>, the message representation is a JSON string that contains the location coordinates, the timestamp and the truck ID.
We build a NSDictionary from these data and serialize it as a JSON string:

[source,objc]
----
NSDictionary *dict = @{
    @"deviceID": self.deviceID,
    @"lat": [NSNumber numberWithDouble:location.coordinate.latitude],
    @"lng": [NSNumber numberWithDouble:location.coordinate.longitude],
    @"ts": [dateFormatter stringFromDate:location.timestamp]
};
NSData *data = [NSJSONSerialization dataWithJSONObject:dict options:0 error:nil];
NSString *body =[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
----

This body follows the JSON format. We will add a +content-type+ header in the STOMP message and set it to +application/json; charset=utf-8+ to let the STOMP brokers and the eventual consumers know that this message's payload can be read as JSON string encoded with UTF-8.
Without such a +content-type+, the consumers would not necessarily know how to _read_ the data in the body and interpret them.

[source,objc]
----
NSDictionary *headers = @{
    @"content-type": @"application/json;charset=utf-8"
};
----

We now have the +destination+, +headers+, and +body+ to send in the message.
Last step is to use the +client+'s +sendTo:headers:body+ method to send it:
[source,objc]
----
// send the message
[self.client sendTo:destination
            headers:headers
               body:body];
----

We will encapsulate all these steps in a +sendLocation:+ method that takes a +CLLocation+ object:

====
[source,objc]
----
- (void)sendLocation:(CLLocation *)location
{
    // build a static NSDateFormatter to display the current date in ISO-8601
    static NSDateFormatter *dateFormatter = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        dateFormatter = [[NSDateFormatter alloc] init];
        dateFormatter.dateFormat = @"yyyy-MM-d'T'HH:mm:ssZZZZZ";
    });

    // send the message to the truck's topic
    NSString *destination = [NSString stringWithFormat:@"/topic/device.%@.location", self.deviceID];

    // build a dictionary containing all the information to send
    NSDictionary *dict = @{
        @"deviceID": self.deviceID,
        @"lat": [NSNumber numberWithDouble:location.coordinate.latitude],
        @"lng": [NSNumber numberWithDouble:location.coordinate.longitude],
        @"ts": [dateFormatter stringFromDate:location.timestamp]
    };
    // create a JSON string from this dictionary
    NSData *data = [NSJSONSerialization dataWithJSONObject:dict options:0 error:nil];
    NSString *body =[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];

    NSDictionary *headers = @{
        @"content-type": @"application/json;charset=utf-8"
    };

    // send the message
    [self.client sendTo:destination
                headers:headers
                   body:body];
}
----
====

Next step is to call this method every time we receive an updated location in the +locationManager:didUpdateToLocation:fromLocation:+ method.

====
[source,objc]
----
- (void)locationManager:(CLLocationManager *)manager
    didUpdateToLocation:(CLLocation *)newLocation
           fromLocation:(CLLocation *)oldLocation
{
    // ignore if the location is older than 30s
    if (fabs([newLocation.timestamp timeIntervalSinceDate:[NSDate date]]) > 30) {
        return;
    }

    CLLocationCoordinate2D coord = [newLocation coordinate];
    self.currentPositionLabel.text = [NSString stringWithFormat:@"φ:%.4F, λ:%.4F", coord.latitude, coord.longitude];

    // send a message with the location data
    [self sendLocation:newLocation];
}
----
====

When we run the application, a STOMP message will be sent every time the location manager updates the device's location.

How can we check that messages are effectively sent?

We will confirm it at three different stages:

* display debug log on the device to check that messages are sent
* use ActiveMQ  administration console to check that it effectively handled the sent messages
* write the simplest STOMP consumer that can receive these messages.

==== Display +StompKit+ debug log.

Every time the StompKit library sends a message to a STOMP broker, it logs the STOMP frame that is sent.

To display them in the console, edit the file named +StompKit.m+ in Xcode that is under the +Pods+ project (its full path is +Pods+ > +Pods+ > +StompKit+ > +StompKit.m+ in the Project Navigator view) and change the macro to activate logs by replacing the +0+ by +1+.

[source,objc]
----
#pragma mark Logging macros

#if 1 // set to 1 to enable logs

...
----

If we restart the application, we now see debug statements in Xcode's Debug console:

----
2014-03-13 17:19:05.711 Locations[79549:60b] >>> SEND
destination:/topic/device.2262EC25-E9FD-4578-BADE-4E113DE45934.location
content-type:application/json;charset=utf-8
content-length:122

{"lng":-122.03254905,"deviceID":"2262EC25-E9FD-4578-BADE-4E113DE45934","lat":37.33521504,"ts":"2014-03-13T17:19:05+01:00"}
...
----

This confirms that STOMP messages are effectively sent by the +Locations+ application.

==== ActiveMQ Admin Console

In <<app_activemq_admin_console>>, we have used the ActiveMQ admin console to check the broker configuration. We can also use this console to check the destinations and their associated metrics.

Go to the ActiveMQ admin console in your Web browser at http://localhost:8161/hawtio[http://localhost:8161/hawtio] and navigate the ActiveMQ tree down to the postion topic in +mybroker > Topic > device.2262EC25-E9FD-4578-BADE-4E113DE45934.location+.

In the right side panel, select +Attributes+ in the top menu to display all the attributes associated to this topic.

To check whether the broker is receiving the messages on this destination, the attribute to check is +Enqueue count+. It corresponds to the messages that has been _enqueued_ (or in other word, _sent_) to the destination. We see that this value is growing over time (it was at +113+ when the screenshot below was captured). This confirms that the broker is actually receiving the messages sent by the mobule application.

[[img_mobile_stomp_16]]
.Check the number of messages sent to a destination in ActiveMQ admin console
image::images/Chapter020/activemq_admin_console_topic_enqueue_count.png["Check the number of messages sent to a destination in ActiveMQ admin console"]

Another interesting attribute is +Dequeue count+. It corresponds to the messages removed from the topic and sent to consumers. In our case, it stays at +0+ because there is no consumer that are subscribed to this destination.

==== A Simple STOMP Consumer

When I presented STOMP, I wrote that the protocol is so simple that a +telnet+ client _is_ a STOMP client.

Let's prove that by writing the simplest STOMP client that will consume the messages sent by the application to the destination.

We need to open a +telnet+ client to connect to the broker host on the +61613+ port. Since I am on the same machine than the broker, I will simply connect to +localhost+:

.Connection with a telnet client
====
++++
<screen>
$ <userinput>telnet localhost 61613</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
</screen>
++++
====

Once the client is connected, we must connect to the broker to open a STOMP connection (as we did in the application using +STOMPClient+'s +connectWithHeaders:completionHandler:+ method).

.Connect to a STOMP broker
====
++++
<screen>
<userinput>CONNECT

</userinput>^@
</screen>
++++
====

[CAUTION]
====
A STOMP frame must be ended by a NULL octet.

The +^@+ is the ASCII character for NULL octet. Type +ctrl + @+ to enter it.
====

Note also that there is a blank line between the +CONNECT+ line and the NULL octet. This blank line is mandatory to separate the command name and the headers from the beginning of the optional payload (that is not present in the +CONNECT+ frame).

Once you type +ctrl + @+, the messaging broker will process the +CONNECT+ frame
and reply with a +CONNECTED+ frame:

.Receive a connection confirmation
====
++++
<screen>
CONNECTED
heart-beat:0,0
session:ID:jeff.local-63055-1391518653216-2:23
server:ActiveMQ/5.9.0
version:1.2
</screen>
++++
====

The STOMP connection is now established and the telnet client can now exchange messages with the broker. We are only interested to consume messages sent by the application on the truck's position topic.
The Truck ID is displayed on the application screen. You will have to adapt the command to use your own truck ID to receive its message.

----
SUBSCRIBE
destination:/topic/device.2262EC25-E9FD-4578-BADE-4E113DE45934.locatio

^@
----

As soon as we sent this command to the STOMP broker, we will receive +MESSAGE+ frames that corresponds to the messages sent by the application:

----
MESSAGE
content-type:application/json;charset=utf-8
message-id:ID:jeff.local-50971-1394726830317-2:5:-1:1:323
destination:/topic/device.2262EC25-E9FD-4578-BADE-4E113DE45934.location
timestamp:1394727930755
expires:0
content-length:122
priority:4

{"lng":-122.12966111,"deviceID":"2262EC25-E9FD-4578-BADE-4E113DE45934","lat":37.36492641,"ts":"2014-03-13T17:25:30+01:00"}
----

[NOTE]
====
We can see that there are more headers in the consumed messages that in the messages we sent (which only had +content-type+ and +content-length+).
These headers are added by the STOMP broker and provides additional metadata about the messages. We will explore some of them later in <<ch_advanced_stomp>> and <<ch_beyond_stomp>>.
====

At this stage, we have a mobile application that is a STOMP _producer_. It broadcasts its position by sending messages to a STOMP destination.

=== Display the Text Messages

We will now write the second part of the +Locations+ application that will _consume_ STOMP messages containing some text and display them in a table.

We will write the graphical part first by adding a +UITable+ to the user interface.

Click on +Main.storyboard+ to open it. From the +Object+ library, drag a +Table View+ on the View's window. Place it below the current position +UILabel+.

[[img_mobile_stomp_16]]
.Add a Table View
image::images/Chapter020/table_view.png["Add a Table View"]

From the +Object+ library, drag a +Table View Cell+ inside the +Table View+.

[[img_mobile_stomp_17]]
.Add a Table View Cell
image::images/Chapter020/table_view_cell.png["Add a Table View Cell"]

We will change the +Table View Cell+ properties by setting its +Style+ to +Basic+ and its +Identifier+ to +TextCell+.

[[img_mobile_stomp_18]]
.Edit the Table View Cell Properties
image::images/Chapter020/table_view_cell_options.png["Edit the Table View Cell Properties"]

The +MWMViewController+ interface will be declared as both the data source and delegate of the table. Open the +MWMViewController.m+ file, make the +MWMViewController+ interface conform to the +UITableViewDataSource+ and +UITableViewDelegate+ protocols and add an outlet property for the table.

====
[source, objc]
----
@interface MWMViewController () <CLLocationManagerDelegate, UITableViewDataSource, UITableViewDelegate>

@property (weak, nonatomic) IBOutlet UITableView *tableView;

@end
----
====

We need to bind this outlet property to the table view. Open the +Main.storyboard+ and control-click on +View Controller+ to see its connection panel. Drag from +tableView+ to the table to connect it.

[[img_mobile_stomp_18]]
.Connect the +tableView+ outlet property to the +Table View+.
image::images/Chapter020/table_view_connection.png[Connect the tableView outlet property to the Table View]

We also need to connect the +View Controller+ to the +Table View+ and declare it as it +dataSource+ and +delegate+.

Open the +Main.storyboard+ and control-click on +Table View+ to see its connection panel. Drag from +dataSource+ to the +View Controller+ to connect it.

[[img_mobile_stomp_19]]
.Connect the +Table View+'s +dataSource+ to the +View Controller+.
image::images/Chapter020/table_view_dataSource_connection.png[Connect the Table View's dataSource to the View Controller]

We do the same operation to connect the +Table View+'s +delegate+ property to the +View Controller+.

[[img_mobile_stomp_20]]
.Connect the +Table View+'s +delegate+ to the +View Controller+.
image::images/Chapter020/table_view_delegate_connection.png[Connect the Table View's delegate to the View Controller]

The graphical objects are now properly connected to the properties. Next step is to make the +MWMViewController+ implementation comply to the +UITableViewDataSource+ and +UITableViewDelegate+ protocols.

The table will only display the received text messages. As there is no interaction with the table, we do not need to add any methods from the +UITableViewDelegate+
protocol. Let's just add a comment to the +MWMViewController+ implementation to remember that.

[source, objc]
----
#pragma mark - UITableViewDelegate

// no delegate actions
----

The controller is also the +dataSource+ of the table. We will keep a list of the texts in memory in an array. Let's add a +texts+ array to the +MWMViewController+ implementation and instatiate it in its +viewDidLoad+ method.

[source, objc]
----
@implementation MWMViewController

// the texts are stored in an array of NSString.
NSMutableArray *texts;

- (void)viewDidLoad
{
    [super viewDidLoad];

    self.deviceID = [UIDevice currentDevice].identifierForVendor.UUIDString;
    NSLog(@"Device identifier is %@", self.deviceID);

    self.client = [[STOMPClient alloc] initWithHost:kHost port:kPort];

    texts = [[NSMutableArray alloc] init];
}

----

This +texts+ array will be used as the source of data for the table.
Let's implement the required +UITableViewDataSource+ methods.

[source, objc]
----
#pragma mark - UITableViewDataSource protocol

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return [texts count];
}

- (UITableViewCell *)tableView:(UITableView *)tableView
         cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    // this identifier must be the same that was set in the
    // Table View Cell properties in the story board.
    static NSString *CellIdentifier = @"TextCell";

    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];

    cell.textLabel.text = [texts objectAtIndex:indexPath.row];
    return cell;
}
----

With these methods implemented, the table will displayed all the texts that are stored in the +texts+ array.

=== Receive STOMP Messages

Now that we are ready to display the texts in the table, next step is to subscribe to the device's text destination to consume STOMP messages containing the texts and store them in the +texts+ array.

To consume messages, a STOMP client must:

. connect to the broker
. subscribe to the destination it wants to consume messages from.


[[ch_mobile_stomp_subscribe]]
==== Subscribe to a STOMP destination

We already took care of step (1) by calling +STOMPClient+'s +connectWithHeaders:completionHandler:+ in +MWMViewController+'s +connect+ method.

Step (2) is handled in STOMPKit by calling +STOMPClient+'s +subscribeTo:headers:messageHandler:+ method.

This method takes 3 parameters:

* the +destination+ that the client wants to consume from. In our case it is the destination +/queue/device.XXX.text+ (we prepended the destination with the +/queue/+ prefix according to ActiveMQ naming convention).
* a dictionary of +headers+ to pass additional metadata to the connection process. Since we do not have any such header for the time being, we will pass a empty dictionary
* a +STOMPMessageHandler+ block with a +STOMPMessage+ parameter that will be called every time the broker sends a messages to the client to consume it. In our case, we will have to create a dictionary from the JSON string contained in the message body and add the order to the +texts+ array.

We will add a method named +subscribe+ to the +MWMViewController+ implementation:

[source, objc]
----
#pragma mark - Messaging

- (void)subscribe
{
    // susbscribes to the device text queue:
    NSString *destination = [NSString stringWithFormat:@"/queue/device.%@.text", self.deviceID];

    NSLog(@"subscribing to %@", destination);
    subscription = [self.client subscribeTo:destination
                                    headers:@{}
                             messageHandler:^(STOMPMessage *message) {
        // called every time a message is consumed from the destination
        NSLog(@"received message %@", message);
        // the text is send in a plain String, we use it as is.
        NSString *text = message.body;
        NSLog(@"adding text = %@", text);
        [texts addObject:text];
        // TODO reload the table
    }];
}
----

+subscription+ is a object returned by the +subscribe+ method that identifies the STOMP subscription and can be used to _unsubscribe_.

We declare this object in the +MWMViewController+'s implementation.

[source,objc]
----
@implementation MWMViewController

STOMPSubscription *subscription;
----

When should we call this +subscribe+ method? As soon as we are connected to the STOMP broker. We need to call it in the +connect+ method from the +completionHandler+ block that will be called when the client is _successfully_ connected to the STOMP broker:

[source,objc]
----
#pragma mark - Messaging

- (void)connect
{
    NSLog(@"Connecting...");
    [self.client connectWithHeaders:@{ @"client-id": self.deviceID}
                  completionHandler:^(STOMPFrame *connectedFrame, NSError *error) {
                      if (error) {
                          // We have not been able to connect to the broker.
                          // Let's log the error
                          NSLog(@"Error during connection: %@", error);
                      } else {
                          // we are connected to the STOMP broker without an error
                          NSLog(@"Connected");
                          [self subscribe];
                      }
                  }];
    // when the method returns, we can not assume that the client is connected
}
----

=== Unsubscribe From the Destination

The application will consume messages from the destination as long as it remains connected to the STOMP broker.

We do not need to explicitly unsubscribe from the destination when we disconnect from the broker but it is a good practice to do so. To unsubscribe, we just need to call the +unsubscribe+ method on the +subscription+ object that was created when we subscribed to the text destination. We will unsubscribe just prior to disconnecting from the broker in the +viewDidDisappear:+ method.

[source,objc]
----
- (void)viewDidDisappear:(BOOL)animated
{
    [self stopUpdatingCurrentLocation];
    [subscription unsubscribe];
    [self disconnect];
}
----

=== Finish the Application

The application is now ready to consume messages. Let's start it and check that it is working.

Run the application in the iOS simulator or on your device.

Go to the ActiveMQ admin console and browse to the device text destination (in my case, its name is +device.2262EC25-E9FD-4578-BADE-4E113DE45934.text+) and click on the +Send+ tab.

Fill the text area with a plain text string and set the +body format+ to +Plain Text+

----
Hello, where are you?
----

[[img_mobile_stomp_21]]
.Send a Message using ActiveMQ Admin Console.
image::images/Chapter020/activemq_admin_send_message.png["Send a Message using ActiveMQ Admin Console"]

Click on the +Send Message+ button to send the message on the destination.

We see in the application log that a STOMP message has been received and that the +text+ was extracted from the message's body.

----
2014-03-14 14:24:19.807 Locations[86050:3903] received message MESSAGE
priority:0
destination:/queue/device.2262EC25-E9FD-4578-BADE-4E113DE45934.text
timestamp:1394803459806
message-id:ID\cjeff.local-53346-1394795959634-37\c1\c1\c1\c1
expires:0
subscription:sub-0

Hello, where are you?
2014-03-14 14:24:19.808 Locations[86050:3903] adding text = Hello, where are you?
----

However, nothing is displayed in the application. We forgot to reload the table to display the received orders.

Let's fix that by calling +reloadData+ on the +tableView+ property from the +STOMPMessageHandler+ block.

[source,objc]
----
- (void)subscribe
{
    // susbscribes to the device text queue:
    NSString *destination = [NSString stringWithFormat:@"/queue/device.%@.text", self.deviceID];

    NSLog(@"subscribing to %@", destination);
    subscription = [self.client subscribeTo:destination
                                    headers:@{}
                             messageHandler:^(STOMPMessage *message) {
        // called every time a message is consumed from the destination
        NSLog(@"received message %@", message);
        // the text is send in a plain String, we use it as is.
        NSString *text = message.body;
        NSLog(@"adding text = %@", text);
        [texts addObject:text];
        dispatch_async(dispatch_get_main_queue(), ^{
            [self.tableView reloadData];
        });
    }];
}
----

Note that we did not call directly +[self.tableView reloadData];+ from the +STOMPMessageHandler+ block.

STOMPKit uses Grand-Central Dispatch's global queue to handle the communication between the client and the STOMP brokers. The +STOMPMessageHandler+ block is called on that queue. However any code that deals with +UIKit+ (such as reloading the +tableView+) *must* be executed on the queue bound to the main thread. This is why we must wrap the +reloadData+ call into a block executed on the main queue.

If we restart the application and send another message on the destination with ActiveMQ admin console, the table will display the text as soon as it is received.

[[img_mobile_stomp_22]]
.The Received Text is Displayed in the Table.
image::images/Chapter020/received_message.png["The Received Text is Displayed in the Table"]

=== Summary

In this chapter, we learn to use +StompKit+ to send and receive STOMP messages from an iOS application.

To send a message, the application must:

. connect to the STOMP broker
. send the message to the destination

To consume a message, the application must

. connect to the STOMP broker
. subscribe to the destination and pass a block that is called every time a message is received. This block is executed on GCD global queue. If there are any code that changes the user interface, it must be wrapped in a block executed on the main queue.

We use two different types of message payloads:

* a JSON payload by using its string representation for the message body and specifying +application/json; charset=utf-8+ in its +content-type+ header
* a simple plain text payload using a string in its payload without any +content-type+ header.

Sending and consuming messages are only possible once the client is _successfully_ connected to the STOMP broker. Due to the event-driven design of StompKit, this is the case when the completionHandler block is executed without an error in +connectWithHeaders:completionHandler:+.
