[[ch_mobile_stomp]]
== Mobile Messaging With STOMP

[role="lead"]
In this chapter, we will write our first messaging client: an native application running on an iPhone. 
We will use the STOMP protocol to send and receive messages using StompKit, an Objective-C implementation of the protocol.

=== STOMP

For the next four chapters, we will use the STOMP protocol to build our applications.

STOMP is a simple text-based messaging protocol that is well suited to build lightweight messaging applications on any platforms.

STOMP provides an interoperable wire format so that clients can communicate with any message broker.
The simplicity of the protocol ensures that it's straightforward to have interoperability between any client and brokers.

This book covers the latest released version of the protocol at the time of this writing: http://stomp.github.io/stomp-specification-1.2.html[STOMP 1.2].

=== StompKit

To use STOMP on iOS, we will use the StompKit library that implements the STOMP protocol in a modern event-driven way using ARC, Grand Central Dispatch and blocks.

=== Create The +TruckTracker+ project With Xcode

We will use https://developer.apple.com/xcode/[Xcode] to create the +TruckTracker+ application.

Once Xcode is installed and started, we create a new project from its launch screen:

[[img_mobile_stomp_1]]
.Select **`Create a new Xcode project" from Xcode launch screen**`.
image::images/Chapter020/xcode_launch_screen.png["XCode Launch screen"]

The application consists in a single view so we choose the **`Single View Application`** template in iOs > Application from the template screen.

[[img_mobile_stomp_2]]
.Select iOs > Application > **`Single View Application`**.
image::images/Chapter020/template_screen.png["XCode template screen"]

We will call the project **`TruckTracker`** and select to build it only for iPhone devices.

[[img_mobile_stomp_3]]
.XCode project options screen
image::images/Chapter020/project_options_screen.png["XCode project options screen"]

Finally we will save it in a folder on our machine.

=== Create the Podfile

To import the library that we will use to send and receive messages, we will setup the project to use _CocoaPods_, an Objective-C Library Manager.

First we need to close Xcode because we will modify the project structure to import our dependencies.

After we have installed CocoaPods using the instructions on http://cocoapods.org[its web site], we create a file at the root of the project (in the same directory than **`TruckTracker.xcodeproj`**) named _Podfile_.

[[ex_mobile_stomp_1]]
.TruckTracker's Podfile
====
----
xcodeproj 'TruckTracker.xcodeproj'

pod 'StompKit', :git => 'https://github.com/mobile-web-messaging/StompKit.git'

platform :ios, '5.0'
----
====

After this file is saved, run the **`pod install`** command.

[[ex_mobile_stomp_2]]
.Install TruckTracker dependencies
====
----
$ pod install
Analyzing dependencies
Pre-downloading: `StompKit` from `https://github.com/mobile-web-messaging/StompKit.git`
Downloading dependencies
Installing CocoaAsyncSocket (7.3.2)
Installing StompKit (0.1.1)
Generating Pods project
Integrating client project

[!] From now on use `TruckTracker.xcworkspace`.
----
====

We can now open again Xcode but we must do it using the *worspace* file named **`TruckTracker.xcworkspace`**, not the *project* file **`TruckTracker.xcodeproj`**.

[[img_mobile_stomp_4]]
.Open the workspace file
image::images/Chapter020/open_worskpace.png["Open the workspace file"]

First, let's make sure that the project is setup correctly and that the application can run in the iOS simulator.

We will simulate the latest iPhone devices by selecting **`Product`** > **`Destination`** > **`iPhone Retina (4-inch 64-bit)`** from Xcode menu bar.
If we run the application by selecting **`Product`** > **`Run`** (or pressing **`⌘R`**), the iOS simulator starts and opens the application which is composed of a blank view.

[[img_mobile_stomp_5]]
.TruckTracker Blank View
image::images/Chapter020/blank_view.png["TruckTracker Blank View"]

Nothing is displayed but it confirms that the project and its dependencies can be successfully compiled and executed.

=== Identify the truck

The iPhone device is used by the truck driver to broadcast its position. The first thing to do is identify the truck. To keep the example simple, we will use a _universal unique identifier_ (or UUID) as the truck identity and display it in the view.

Since the app will run only on iPhone devices, all the user interface will be setup in the **`Main.storyboard`** file.

Click on **`Main.storyboard`** to open it. From the `Object` library, drag a label on the `View`'s window. Place it at the top of the view and change the label to `Truck ID`. Make it as wide as possible.

[[img_mobile_stomp_6]]
.Make the label as wide as the window.
image::images/Chapter020/truckID_label_wide.png["Make the label as wide as the window"]

We will change its appearance by setting its **`Font`** to **`System 13.0`** and its **`Alignment`** to centered.

[[img_mobile_stomp_7]]
.Set the alignment to centered.
image::images/Chapter020/truckID_Label_options.png["Set the alignment to centered"]

We will connect this label to the `MWMViewController` object.

Add the necessary outlet property in **`MWMViewController.m`** and a NSString to hold the identifier.

[source,objc]
----
@interface MWMViewController ()

@property (weak, nonatomic) IBOutlet UILabel *truckIDLabel;

@property (copy, nonatomic) NSString *truckID;

@end
----

Open the **`Main.storyboard`** and control-click on +View Controller+ to see its connection panel. Drag from +truckIdLabel+ to the +UILabel+ to connect it.

[[img_mobile_stomp_8]]
.Connect the label to the outlet property.
image::images/Chapter020/truckID_label_connection.png["Connect the label to the outlet property"]

Now that the outlet property is connected to the label, we need to generate a UUUID for the application and display it when the view appears.

Open **`MWMViewController.m`** to add code to the **`MWMViewController`** _implementation_. When the application starts and the view is loaded in **`viewDidLoad`**, we set the +truckID+ using a UUID.

[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];

    self.truckID = [UIDevice currentDevice].identifierForVendor.UUIDString;
}
----

.About Unique Identifier
[NOTE]
====
The **`identifierForVendor`** property will uniquely identify the device for the application's vendor (that we set to **`net.mobile-web-messaging`** when we create the project). That is enough for the purpose of our example but in a real application, the truck driver would likely have to login and authenticate himself when the application is started and fetch its truck ID from the company's servers.
====

We also need to set the label to this ID when the view will appear.

[source,objc]
----
- (void)viewWillAppear:(BOOL)animated
{
    self.truckIDLabel.text = self.truckID;
}
----

If we run the application, we will see the truck ID displayed instead of +Truck ID+ in the view.

[[img_mobile_stomp_9]]
.Display the truck ID.
image::images/Chapter020/view_with_truckID.png["Display the truck ID"]

Now that we have the identifier of the truck, the next step is to retrieve the geolocation data from the device using the **`CoreLocation`** framework so that we can send them in a STOMP message

[NOTE]
====
The next sections deal with setting up the framework and writing code to retrieve the GPS data from the device. This is unrelated to messaging and you can skip them if you only want to read how to send and receive messages. Still, we thought the messaging code would be more meaningful if it was using real data instead of generating random data that could not be exploited. By using GPS data instead, we will be able to build a mobile app that display these data in the next chapter.
====

=== Display the truck position

To display the geolocation data from the device's GPS sensor, we will add a +UILabel+ to the view, make it as wide as possible and change its label to  +Current position: ???+

[[img_mobile_stomp_10]]
.TruckTracker View with a to display the current position
image::images/Chapter020/currentPosition_label_wide.png["TruckTracker View with a to display the current position"]

We will change its appearance to match the **`truckID`** label by setting its **`Font`** to **`System 13.0`** and its **`Alignment`** to centered.

[[img_mobile_stomp_11]]
.Set the alignment to centered.
image::images/Chapter020/truckID_Label_options.png["Set the alignment to centered"]

Open the **MWMViewController.m`** file and add a property to the **MWMViewController`** _interface.

[source,objc]
----
@property (weak, nonatomic) IBOutlet UILabel *currentPositionLabel;
----

We then we bind this property to the label. Open the **`Main.storyboard`** and control-click on +View Controller+ to see its connection panel. Drag from +currentPositionLabel+ to the label to connect it.

[[img_mobile_stomp_12]]
.Connect the label to the outlet property.
image::images/Chapter020/currentPosition_label_connection.png["Connect the label to the outlet property"]

The label is now connected to the property. The next step is to retrieve the geolocation data from the device to update the property and send a message with them.

=== Access The Device Geolocation Data with +CoreLocation+ Framework

iOS provides the +CoreLocation+ framework to access the location data.

We need to add it to the libraries linked by the app. Click on the +TruckTracker+ project and then the +TruckTracker+ target. In the +General+ tab, under the +Linked Frameworks and Libraries+ section, click on the +++ button. In the selection window, type **`CoreLocation`**, select the +CoreLocation.framework+ and click on the +Add+ button.

[[img_mobile_stomp_13]]
.Add the CoreLocation framework.
image::images/Chapter020/CoreLocation_framework.png["Add the CoreLocation framework"]

We can now use the +CoreLocation+ framework by importing **`<CoreLocation/CoreLocation.h>`** in  **`MWMViewController.m`** file.

We will make the +MWMViewController+ interface conform to the +CLLocationManagerDelegate+ protocol and declare a +CLLocationManager+ property named +locationManager+.

[source,objc]
----
#import <CoreLocation/CoreLocation.h>

interface MWMViewController () <CLLocationManagerDelegate>

@property (strong, nonatomic) CLLocationManager *locationManager;

@end
----











We will define two methods to start and stop updating the current location. When the apps starts updating the current location in +startUpdatingCurrentLocation+, it creates the +locationManager+ if it's not already created and designs the controller as the locationManager's +delegate+. Since the geolocation data will be used to follow a truck, we set the locationManagere's +desiredAccuracy+ to +kCLLocationAccuracyBestForNavigation+.

Then, the app will start listening for the device location by calling locationManager's +startUpdatingLocation+ method.

To stop receiving the device location in +stopUpdatingCurrentLocation+, we simply call locationManager's +stopUpdatingLocation+ method:

[[ex_mobile_stomp_7]]
.MWMViewController.m continued
====
[source,objc]
----
#pragma mark - CoreLocation actions

- (void)startUpdatingCurrentLocation {
    NSLog(@"startUpdatingCurrentLocation");

    // if location services are restricted do nothing
    if ([CLLocationManager authorizationStatus] == kCLAuthorizationStatusDenied ||
        [CLLocationManager authorizationStatus] == kCLAuthorizationStatusRestricted) {
        return;
    }
    
    // if locationManager does not currently exist, create it
    if (!self.locationManager) {
        self.locationManager = [[CLLocationManager alloc] init];
        self.locationManager.delegate = self;
        self.locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation;
    }
    
    [self.locationManager startUpdatingLocation];
}

- (void)stopUpdatingCurrentLocation {
    [self.locationManager stopUpdatingLocation];
}
----
====

The location of the device will be received by the designated +CLLocationManagerDelegate+ (in our case, the +MWMViewController+ implementation).

We need to implement the +locationManager:didUpdateToLocation:fromLocation:+ method and extract the 
coordinates from the +newLocation+'s +coordinate.

Once we have them, we can update the +currentPositionLabel+'s +text+ to display them.

[[ex_mobile_stomp_8]]
.MWMViewController.m continued
====
[source,objc]
----
#pragma mark - CLLocationManagerDelegate

- (void)locationManager:(CLLocationManager *)manager
    didUpdateToLocation:(CLLocation *)newLocation
           fromLocation:(CLLocation *)oldLocation {
    // if the location is older than 30s ignore
    if (fabs([newLocation.timestamp timeIntervalSinceDate:[NSDate date]]) > 30) {
        return;
    }
    
    CLLocationCoordinate2D coord = [newLocation coordinate];
    self.currentPositionLabel.text = [NSString stringWithFormat:@"φ:%.4F, λ:%.4F", coord.latitude, coord.longitude];
}
----
====

If there are any problem with the locationManager, we want to warn the user about it and stop updating the location. To do so, we implement the +CLLocationManagerDelegate+'s +locationManager:didFailWithError:+ method to display a warning to the user:

[[ex_mobile_stomp_8]]
.MWMViewController.m continued
====
[source,objc]
----
- (void)locationManager:(CLLocationManager *)manager
       didFailWithError:(NSError *)error {
    NSLog(@"%@", error);

    // reset the current position label
    self.currentPositionLabel.text = @"Current position: ???";
    
    // show the error alert
    UIAlertView *alert = [[UIAlertView alloc] init];
    alert.title = @"Error obtaining location";
    alert.message = [error localizedDescription];
    [alert addButtonWithTitle:@"OK"];
    [alert show];
}
----
====

The first time we will ask the locationManager to start updating the device location, the user will see an alert view accessing him or her the permission to access the device location.

We will call the +startUpdatingCurrentLocation+ method when either the +truckID+ is already set in +viewWillAppear:+ or when the users enters it in +alertView:clickedButtonAtIndex:+

[[ex_mobile_stomp_9]]
.MWMViewController.m continued
====
[source,objc]
----
- (void)viewWillAppear:(BOOL)animated {
    if (self.truckID) {
        [self startUpdatingCurrentLocation];
        return;
    }
    
    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Truck Identifier"
                                                    message:@"What is the ID of the truck?"
                                                   delegate:self
                                          cancelButtonTitle:nil
                                          otherButtonTitles:@"OK", nil];
    alert.alertViewStyle = UIAlertViewStylePlainTextInput;
    [alert show];
}

- (void)alertView:(UIAlertView *)alert clickedButtonAtIndex:(NSInteger)buttonIndex {
    self.truckID = [alert textFieldAtIndex:0].text;
    self.truckIDLabel.text = self.truckID;
    
    [self startUpdatingCurrentLocation];
}
----
====

We will stop to update the location when the view disappears in +viewDidDisappear:+

[[ex_mobile_stomp_10]]
.MWMViewController.m continued
====
[source,objc]
----
- (void)viewDidDisappear:(BOOL)animated {
    [self stopUpdatingCurrentLocation];
}
----
====

=== Create the STOMP client

In order to use the StompKit library, we must import its header file in **`MWMViewController.m`** and declare a +STOMPClient+ property.

[[ex_mobile_stomp_1]]
.MWMViewController.m
====
[source, objc]
----
#import <StompKit.h>

@interface TTViewController ()

...

@property (strong, nonatomic) STOMPClient *client;

@end
----
====

The +client+ variable is created when the controller's view is loaded in MWMViewController's +viewDidLoad+ method implementation. To create it, we need to pass the host and port of the STOMP broker to connect to.


[[ex_mobile_stomp_2]]
.MWMViewController.m
====
[source, objc]
----
#define kHost     @"localhost"
#define kPort     61613

...

@implementation TTViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    
    self.client = [[STOMPClient alloc] initWithHost:kHost port:kPort];
}

@end
----
====

When the +client+ object is created, it is not connect to the STOMP broker. To connect, we must call its +connectWitHeaders:completionHandler:+ method.

StompKit uses Grand Central Dispatch and blocks to provide an event-driven API. This means that the client is _not_ connected when the call to its +connectWitHeaders:completionHandler:+ method returns but when the completionHandler block is called.

We can pass a dictionary to +connectWitHeaders:completionHandler:+ to add aditional headers when the +CONNECT+ frame is sent. In our app, we will send a +client-id+ header set to the +truckerID+ to uniquely identify the client against the STOMP broker. This ensures that no two apps will be able to connect using the same identifier. Once a client is connected with a given +client-id+, any subsequent clients that uses the same value will fail to connect to the broker.

Let's encapsulate all this ina +connect+ method in **`MWMViewController.m`**:

[[ex_mobile_stomp_3]]
.MWMViewController.m continued
====
[source, objc]
----
@implementation MWMViewController

#pragma mark - Messaging

- (void)connect {
    NSLog(@"Connecting...");
    [self.client connectWithHeaders:@{ @"client-id": self.truckID}
                  completionHandler:^(STOMPFrame *connectedFrame, NSError *error) {
                      if (error) {
                          // We have not been able to connect to the broker.
                          // Let's log the error
                          NSLog(@"Error during connection: %@", error);
                      } else {
                          // we are connected to the STOMP broker without an error
                          NSLog(@"Connected");
                      }
                  }];
    // when the method returns, we can not assume that the client is connected
}

@end
----
====

Before we call this method, we must have set the +truckID+ property.

The first time, we run the application, the +truckID+ property will be set when the user set the truck identifier in the alert view and the +UIAlertViewDelegate+ method +alertView:clickedButtonAtIndex:+ is called.
After this, everytime the view reappears, the +truckID+ will be already set when the controller's 
+viewWillAppear:+ method is called and we can connect from this method.

[[ex_mobile_stomp_4]]
.MWMViewController.m continued
====
[source, objc]
----
- (void)viewWillAppear:(BOOL)animated {
    // the truckID is set, we can connect to the STOMP broker
    if (self.truckID) {
        [self connect];
        return;
    }

    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Truck Identifier"
                                                     message:@"What is the ID of the truck"
                                                    delegate:self
                                           cancelButtonTitle:nil
                                           otherButtonTitles:@"OK", nil];
    alert.alertViewStyle = UIAlertViewStylePlainTextInput;
    [alert show];
}

#pragma mark - UIAlertViewDelegate

- (void)alertView:(UIAlertView *)alert clickedButtonAtIndex:(NSInteger)buttonIndex {
    self.truckID = [alert textFieldAtIndex:0].text;
    self.truckIDText.text = self.truckID;
    NSLog(@"TruckID = %@", self.truckID);
    // the user just entered the truck identifier, let's connect to the STOMP broker
    [self connect];
}

----
====

The STOMPClient disconnects from the broker using its +disconnect:+ method. This method takes a block that will be called when the client is disconnected from the server. The block takes a +NSError+ parameter that is set if there is an error during the disconnection operation.

[[ex_mobile_stomp_5]]
.MWMViewController.m continued
====
[source, objc]
----

#pragma mark - Messaging

- (void)disconnect {
    NSLog(@"Disconnecting...");
    [self.client disconnect:^(NSError *error) {
        if (error) {
            NSLog(@"Error during disconnection: %@", error);
        } else {
            // the client is disconnected from the broker without any problem
            NSLog(@"Disconnected");
        }
    }];
    // when the method returns, we can not assume that the client is disconnected
}
----
====

We will disconnect from the broker when the view will disappear:


[[ex_mobile_stomp_6]]
.MWMViewController.m continued
====
[source, objc]
----
- (void)viewWillDisappear:(BOOL)animated {
    [self disconnect];
}
----
====

At this stage, we have an application that connect to the STOMP broker when its view is displayed and disconnect when its view disappears.


=== Send messages with STOMP

We now have a connection to the STOMP broker and receive the device's geolocation data. The last thing to do is to send these data to the +/topic/truck.data+ topic.

[[ex_mobile_stomp_10]]
.MWMViewController.m continued
====
[source,objc]
----
- (void)sendLocation:(CLLocation *) location {
    
    // build a static NSDateFormatter to display the current date in ISO-8601
    static NSDateFormatter *dateFormatter = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        dateFormatter = [[NSDateFormatter alloc] init];
        dateFormatter.dateFormat = @"yyyy-MM-d'T'HH:mm:ssZZZZZ";
    });
    
    // build a dictionary containing all the information to send
    NSDictionary *dict = @{
                           @"truck": self.truckID,
                            @"lat": [NSNumber numberWithDouble:location.coordinate.latitude],
                           @"lng": [NSNumber numberWithDouble:location.coordinate.longitude],
                           @"ts": [dateFormatter stringFromDate:location.timestamp]
                         };
    // create a JSON string from this dictionary
    NSData *data = [NSJSONSerialization dataWithJSONObject:dict options:0 error:nil];
    NSString *body =[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
    
    [self.client sendTo:@"/topic/truck.position" body:body];
}
----
====

We need to call this method every time we receive an updated location in +locationManager:didUpdateToLocation:fromLocation:+

[[ex_mobile_stomp_11]]
.MWMViewController.m continued
====
[source,objc]
----
- (void)locationManager:(CLLocationManager *)manager
    didUpdateToLocation:(CLLocation *)newLocation
           fromLocation:(CLLocation *)oldLocation {
    // if the location is older than 30s ignore
    if (fabs([newLocation.timestamp timeIntervalSinceDate:[NSDate date]]) > 30) {
        return;
    }
    
    CLLocationCoordinate2D coord = [newLocation coordinate];
    self.currentPositionLabel.text = [NSString stringWithFormat:@"φ:%.4F, λ:%.4F", coord.latitude, coord.longitude];
    
    // send a message with the location data
    [self sendLocation:newLocation];
}
----
====

=== Create the orders table

TODO

=== Receive Messages With STOMP

TODO