[[ch_mobile_stomp]]
== Mobile Messaging With STOMP

[role="lead"]
In this chapter, we will write our first messaging client: an native application running on an iPhone. 
We will use the STOMP protocol to send and receive messages using StompKit, an Objective-C implementation of the protocol.

=== STOMP

For the next four chapters, we will use the STOMP protocol to build our applications.

STOMP is a simple text-based messaging protocol that is well suited to build lightweight messaging applications on any platforms.

STOMP provides an interoperable wire format so that clients can communicate with any message broker.
The simplicity of the protocol ensures that it's straightforward to have interoperability between any client and brokers.

This book covers the latest released version of the protocol at the time of this writing: http://stomp.github.io/stomp-specification-1.2.html[STOMP 1.2].

.Install and configure a messaging broker
[NOTE]
====
Before using a STOMP client, a messaging broker must be installed and
configured to be able to exchange messages.

In this book, we use Apache ActiveMQ as the messaging broker. The <<appendix_activemq>> shows how to install and configure ActiveMQ.

Once ActiveMQ is started, it accepts STOMP connections on the +61613+ port.
====

=== StompKit

To use STOMP on iOS, we will use the StompKit library that implements the STOMP protocol in a modern event-driven way using ARC, Grand Central Dispatch and blocks.

=== Create The +TruckTracker+ project With Xcode

We will use https://developer.apple.com/xcode/[Xcode] to create the +TruckTracker+ application.

Once Xcode is installed and started, we create a new project from its launch screen:

[[img_mobile_stomp_1]]
.Select **`Create a new Xcode project" from Xcode launch screen**`.
image::images/Chapter020/xcode_launch_screen.png["XCode Launch screen"]

The application consists in a single view so we choose the **`Single View Application`** template in iOs > Application from the template screen.

[[img_mobile_stomp_2]]
.Select iOs > Application > **`Single View Application`**.
image::images/Chapter020/template_screen.png["XCode template screen"]

We will call the project **`TruckTracker`** and select to build it only for iPhone devices.

[[img_mobile_stomp_3]]
.XCode project options screen
image::images/Chapter020/project_options_screen.png["XCode project options screen"]

Finally we will save it in a folder on our machine.

=== Create the Podfile

To import the library that we will use to send and receive messages, we will setup the project to use _CocoaPods_, an Objective-C Library Manager.

First we need to close Xcode because we will modify the project structure to import our dependencies.

After we have installed CocoaPods using the instructions on http://cocoapods.org[its web site], we create a file at the root of the project (in the same directory than **`TruckTracker.xcodeproj`**) named _Podfile_.

[[ex_mobile_stomp_1]]
.TruckTracker's Podfile
====
----
xcodeproj 'TruckTracker.xcodeproj'

pod 'StompKit', :git => 'https://github.com/mobile-web-messaging/StompKit.git'

platform :ios, '5.0'
----
====

After this file is saved, run the **`pod install`** command.

[[ex_mobile_stomp_2]]
.Install TruckTracker dependencies
====
----
$ pod install
Analyzing dependencies
Pre-downloading: `StompKit` from `https://github.com/mobile-web-messaging/StompKit.git`
Downloading dependencies
Installing CocoaAsyncSocket (7.3.2)
Installing StompKit (0.1.1)
Generating Pods project
Integrating client project

[!] From now on use `TruckTracker.xcworkspace`.
----
====

We can now open again Xcode but we must do it using the *worspace* file named **`TruckTracker.xcworkspace`**, not the *project* file **`TruckTracker.xcodeproj`**.

[[img_mobile_stomp_4]]
.Open the workspace file
image::images/Chapter020/open_worskpace.png["Open the workspace file"]

First, let's make sure that the project is setup correctly and that the application can run in the iOS simulator.

We will simulate the latest iPhone devices by selecting **`Product`** > **`Destination`** > **`iPhone Retina (4-inch 64-bit)`** from Xcode menu bar.
If we run the application by selecting **`Product`** > **`Run`** (or pressing **`⌘R`**), the iOS simulator starts and opens the application which is composed of a blank view.

[[img_mobile_stomp_5]]
.TruckTracker Blank View
image::images/Chapter020/blank_view.png["TruckTracker Blank View"]

Nothing is displayed but it confirms that the project and its dependencies can be successfully compiled and executed.

=== Identify the truck

The iPhone device is used by the truck driver to broadcast its position. The first thing to do is identify the truck. To keep the example simple, we will use a _universal unique identifier_ (or UUID) as the truck identity and display it in the view.

Since the app will run only on iPhone devices, all the user interface will be setup in the **`Main.storyboard`** file.

Click on **`Main.storyboard`** to open it. From the `Object` library, drag a label on the `View`'s window. Place it at the top of the view and change the label to `Truck ID`. Make it as wide as possible.

[[img_mobile_stomp_6]]
.Make the label as wide as the window.
image::images/Chapter020/truckID_label_wide.png["Make the label as wide as the window"]

We will change its appearance by setting its **`Font`** to **`System 13.0`** and its **`Alignment`** to centered.

[[img_mobile_stomp_7]]
.Set the alignment to centered.
image::images/Chapter020/truckID_Label_options.png["Set the alignment to centered"]

We will connect this label to the `MWMViewController` object.

Add the necessary outlet property in **`MWMViewController.m`** and a NSString to hold the identifier.

[source,objc]
----
@interface MWMViewController ()

@property (weak, nonatomic) IBOutlet UILabel *truckIDLabel;

@property (copy, nonatomic) NSString *truckID;

@end
----

Open the **`Main.storyboard`** and control-click on +View Controller+ to see its connection panel. Drag from +truckIdLabel+ to the +UILabel+ to connect it.

[[img_mobile_stomp_8]]
.Connect the label to the outlet property.
image::images/Chapter020/truckID_label_connection.png["Connect the label to the outlet property"]

Now that the outlet property is connected to the label, we need to generate a UUUID for the application and display it when the view appears.

Open **`MWMViewController.m`** to add code to the **`MWMViewController`** _implementation_. When the application starts and the view is loaded in **`viewDidLoad`**, we set the +truckID+ using a UUID.

[source,objc]
----
- (void)viewDidLoad
{
    [super viewDidLoad];

    self.truckID = [UIDevice currentDevice].identifierForVendor.UUIDString;
}
----

.About Unique Identifier
[NOTE]
====
The **`identifierForVendor`** property will uniquely identify the device for the application's vendor (that we set to **`net.mobile-web-messaging`** when we create the project). That is enough for the purpose of our example but in a real application, the truck driver would likely have to login and authenticate himself when the application is started and fetch its truck ID from the company's servers.
====

We also need to set the label to this ID when the view will appear.

[source,objc]
----
- (void)viewWillAppear:(BOOL)animated
{
    self.truckIDLabel.text = self.truckID;
}
----

If we run the application, we will see the truck ID displayed instead of +Truck ID+ in the view.

[[img_mobile_stomp_9]]
.Display the truck ID.
image::images/Chapter020/view_with_truckID.png["Display the truck ID"]

Now that we have the identifier of the truck, the next step is to retrieve the geolocation data from the device using the **`CoreLocation`** framework so that we can send them in a STOMP message.

[NOTE]
====
The next sections deal with setting up the framework and writing code to retrieve the GPS data from the device and display them. This is unrelated to messaging and you can skip them if you only want to read how to send and receive messages. Still, we thought the messaging code would be more meaningful if it was using real data instead of generating random data that could not be exploited. By using GPS data instead, we will be able to build a mobile app that display these data in the next chapter.
====

=== Display the truck position

We will retrieve the geolocation data from the device's GPS sensor to send them using STOMP messages. However, we also want to have some graphical feedback to show that the data changes over the time as we move with our device.

To display the geolocation data, we will add a +UILabel+ to the view, make it as wide as possible and change its label to  +Current position: ???+

[[img_mobile_stomp_10]]
.TruckTracker View with a to display the current position
image::images/Chapter020/currentPosition_label_wide.png["TruckTracker View with a to display the current position"]

We will change its appearance to match the **`truckID`** label by setting its **`Font`** to **`System 13.0`** and its **`Alignment`** to centered.

[[img_mobile_stomp_11]]
.Set the alignment to centered.
image::images/Chapter020/truckID_Label_options.png["Set the alignment to centered"]

Open the **MWMViewController.m`** file and add a property to the **MWMViewController`** _interface.

[source,objc]
----
@property (weak, nonatomic) IBOutlet UILabel *currentPositionLabel;
----

We then bind this property to the label. Open the **`Main.storyboard`** and control-click on +View Controller+ to see its connection panel. Drag from +currentPositionLabel+ to the label to connect it.

[[img_mobile_stomp_12]]
.Connect the label to the outlet property.
image::images/Chapter020/currentPosition_label_connection.png["Connect the label to the outlet property"]

The label is now connected to the property. The next step is to retrieve the geolocation data from the device to update the property and send a message with them.

=== Access The Device Geolocation Data with +CoreLocation+ Framework

iOS provides the +CoreLocation+ framework to access the location data.

We need to add it to the libraries linked by the app. Click on the +TruckTracker+ project and then the +TruckTracker+ target. In the +General+ tab, under the +Linked Frameworks and Libraries+ section, click on the +++ button. In the selection window, type **`CoreLocation`**, select the +CoreLocation.framework+ and click on the +Add+ button.

[[img_mobile_stomp_13]]
.Add the CoreLocation framework.
image::images/Chapter020/CoreLocation_framework.png["Add the CoreLocation framework"]

We can now use the +CoreLocation+ framework by importing **`<CoreLocation/CoreLocation.h>`** in  **`MWMViewController.m`** file.

We will make the +MWMViewController+ interface conform to the +CLLocationManagerDelegate+ protocol and declare a +CLLocationManager+ property named +locationManager+.

[source,objc]
----
#import <CoreLocation/CoreLocation.h>

interface MWMViewController () <CLLocationManagerDelegate>

@property (strong, nonatomic) CLLocationManager *locationManager;

@end
----

We will define two methods to start and stop updating the current location. When the apps starts updating the current location in +startUpdatingCurrentLocation+, it creates the +locationManager+ if it's not already created and designs the controller as the locationManager's +delegate+. Since the geolocation data will be used to follow a moving object such as a truck, we set the locationManagere's +desiredAccuracy+ to +kCLLocationAccuracyBestForNavigation+.

Then, the app will start listening for the device location by calling locationManager's +startUpdatingLocation+ method.

====
[source,objc]
----
#pragma mark - CoreLocation actions

- (void)startUpdatingCurrentLocation
{
    NSLog(@"startUpdatingCurrentLocation");

    // if location services are restricted do nothing
    if ([CLLocationManager authorizationStatus] == kCLAuthorizationStatusDenied ||
        [CLLocationManager authorizationStatus] == kCLAuthorizationStatusRestricted) {
        return;
    }
    
    // if locationManager does not currently exist, create it
    if (!self.locationManager) {
        self.locationManager = [[CLLocationManager alloc] init];
        // set its delegate to self
        self.locationManager.delegate = self;
        // use the accuracy best suite for navigation
        self.locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation;
    }
    
    // start updating the location
    [self.locationManager startUpdatingLocation];
}
----
====

To stop receiving the device location in +stopUpdatingCurrentLocation+, we simply call locationManager's +stopUpdatingLocation+ method.

====
[source,objc]
----
- (void)stopUpdatingCurrentLocation
{
    [self.locationManager stopUpdatingLocation];
}
----
====

The location of the device will be received by the designated +CLLocationManagerDelegate+ (in our case, the +MWMViewController+ implementation). We need to implement the +locationManager:didUpdateToLocation:fromLocation:+ method and extract the 
coordinates from the +newLocation+'s +coordinate.

Once we have them, we can update the +currentPositionLabel+'s +text+ to display them.

====
[source,objc]
----
#pragma mark - CLLocationManagerDelegate

- (void)locationManager:(CLLocationManager *)manager
    didUpdateToLocation:(CLLocation *)newLocation
           fromLocation:(CLLocation *)oldLocation
{
    // ignore if the location is older than 30s
    if (fabs([newLocation.timestamp timeIntervalSinceDate:[NSDate date]]) > 30) {
        return;
    }
    
    CLLocationCoordinate2D coord = [newLocation coordinate];
    self.currentPositionLabel.text = [NSString stringWithFormat:@"φ:%.4F, λ:%.4F", coord.latitude, coord.longitude];
}
----
====

If there are any problem with the locationManager, we want to warn the user about it and stop updating the location. To do so, we implement the +CLLocationManagerDelegate+'s +locationManager:didFailWithError:+ method to display a warning to the user:

====
[source,objc]
----
- (void)locationManager:(CLLocationManager *)manager
       didFailWithError:(NSError *)error
{
    // reset the current position label
    self.currentPositionLabel.text = @"Current position: ???";
    
    // show the error alert
    UIAlertView *alert = [[UIAlertView alloc] init];
    alert.title = @"Error obtaining location";
    alert.message = [error localizedDescription];
    [alert addButtonWithTitle:@"OK"];
    [alert show];
}
----
====

We will call the +startUpdatingCurrentLocation+ method when the view will appear.

====
[source,objc]
----
- (void)viewWillAppear:(BOOL)animated
{
    self.truckIDLabel.text = self.truckID;
    
    [self startUpdatingCurrentLocation];
}

----
====

We will stop to update the location when the view disappears in +viewDidDisappear:+

====
[source,objc]
----
- (void)viewDidDisappear:(BOOL)animated
{
    [self stopUpdatingCurrentLocation];
}
----
====

The first time the app asks the locationManager to start updating the device location, the user will see an alert view accessing him or her the permission to access the device location.

[[img_mobile_stomp_14]]
.Permission to use the current location.
image::images/Chapter020/current_location_permission.png["Permission to use the current location"]

If the user clicks **`OK`**, the +locationManager+ will start update the device location and the currentPositionLabel will be updated with the latitude and longitude.

[[img_mobile_stomp_15]]
.Display the geolocation position.
image::images/Chapter020/current_position.png["Display the geolocation position"]

If you are running the application on an iPhone device, the real geolocation data from the device will be used.
If you run the application using the +iOS Simulator+, you can simulate different location in the **`Debug`** > **`Location`** menu. For example, the **`Freeway Drive`** will simulate a car driving on a freeway between Palo Alto and San Francisco.

Whether you are running the application on a device or in the simulator, you should see the +currentPositionLabel+ be udpated.

We now display the geolocation data. Next step is to send them using STOMP.

=== Create a STOMP client with StompKit

Before sending any messages, we must first import the StompKit library that we add to our _Podfile_ file at the beginning of this chapter.

We must import its header file in **`MWMViewController.m`** and add a +STOMPClient+ property name **`client`** to the +MWMViewController+ interface.

====
[source, objc]
----
#import <StompKit.h>

@interface MWMViewController () <CLLocationManagerDelegate>

@property (nonatomic, strong) STOMPClient *client;

@end
----
====

The +client+ property will be used to communicate with the STOMP broker after it is created and connected.

The +client+ variable is created when the controller's view is loaded in MWMViewController's +viewDidLoad+ method implementation. To create it, we need to pass the host and port of the STOMP broker to connect to.
These information depends on the broker you are using. If you have configured ActiveMQ as described in the appendix on your machine, we can connect to it using **`61613`** as its port.

The host will depend on your network configuration. On my local network, my server has the IP address **`192.168.1.25`**. I will use this value for the examples but you might replace this by your own server address to run the applications.

====
[source, objc]
----
#define kHost     @"192.168.1.25"
#define kPort     61613

...

@implementation MWMViewController

- (void)viewDidLoad
{
    [super viewDidLoad];

    self.truckID = [UIDevice currentDevice].identifierForVendor.UUIDString;

    self.client = [[STOMPClient alloc] initWithHost:kHost port:kPort];
}

@end
----
====

=== Connect to a STOMP broker

When the +client+ object is created, it is not connect to the STOMP broker yet. To connect, we must call its +connectWitHeaders:completionHandler:+ method.

StompKit uses Grand Central Dispatch and blocks to provide an event-driven API. This means that the client is _not_ connected when the call to its +connectWitHeaders:completionHandler:+ method returns but when the completionHandler block is called.

We can pass a dictionary to +connectWitHeaders:completionHandler:+ to add aditional headers when the +CONNECT+ frame is sent. In our app, we will send a +client-id+ header set to the +truckerID+ to uniquely identify the client against the STOMP broker. This ensures that no two apps will be able to connect using the same identifier. Once a client is connected with a given +client-id+, any subsequent clients that uses the same value will fail to connect to the broker.

Let's encapsulate all this in a +connect+ method in **`MWMViewController.m`**:

====
[source, objc]
----
@implementation MWMViewController

#pragma mark - Messaging

- (void)connect
{
    NSLog(@"Connecting...");
    [self.client connectWithHeaders:@{ @"client-id": self.truckID}
                  completionHandler:^(STOMPFrame *connectedFrame, NSError *error) {
                      if (error) {
                          // We have not been able to connect to the broker.
                          // Let's log the error
                          NSLog(@"Error during connection: %@", error);
                      } else {
                          // we are connected to the STOMP broker without an error
                          NSLog(@"Connected");
                      }
                  }];
    // when the method returns, we can not assume that the client is connected
}

@end
----
====

We then only need to call this +connect+ method when the view appears in +viewWillAppear:+.

====
[source, objc]
----
- (void)viewWillAppear:(BOOL)animated
{
    self.truckIDLabel.text = self.truckID;
    
    [self startUpdatingCurrentLocation];
    [self connect];
}
----
====

=== Disconnect from a STOMP broker.

The STOMPClient disconnects from the broker using its +disconnect:+ method. This method takes a block that will be called when the client is disconnected from the server. The block takes a +NSError+ parameter that is set if there is an error during the disconnection operation.

====
[source, objc]
----
#pragma mark - Messaging

- (void)disconnect
{
    NSLog(@"Disconnecting...");
    [self.client disconnect:^(NSError *error) {
        if (error) {
            NSLog(@"Error during disconnection: %@", error);
        } else {
            // the client is disconnected from the broker without any problem
            NSLog(@"Disconnected");
        }
    }];
    // when the method returns, we can not assume that the client is disconnected
}
----
====

We will disconnect from the broker once the view has disappeared in +viewDidDisappear:+.

====
[source, objc]
----
- (void)viewDidDisappear:(BOOL)animated
{
    [self stopUpdatingCurrentLocation];
    [self disconnect];
}
----
====

At this stage, we have an application that connect to the STOMP broker when its view is displayed and disconnect when its view disappears.

If we run the application, we see logs in Xcode that shows the connection process:

----
2014-01-27 18:18:12.097 TruckTracker[14578:70b] Connecting...
2014-01-27 18:18:12.181 TruckTracker[14578:1303] Connected
----

=== Send messages

We now have a connection to the STOMP broker and we receive the device's geolocation data from the location manager. The last step to do is to send these data to the topic associated to the truck ID.

As we described in <<ch_introduction_example>>, each truck's device will send its location on a topic destination named after the truck ID.

[source,objc]
----
NSString *destination = [NSString stringWithFormat:@"/topic/truck.%@.position", self.truckID];
----

The message representation is a JSON string that contains the location coordinates, the timestamp and the truck ID.
We build a NSDictionary from these data and serialize it as a JSON string:

[source,objc]
----
NSDictionary *dict = @{
    @"truck": self.truckID,
    @"lat": [NSNumber numberWithDouble:location.coordinate.latitude],
    @"lng": [NSNumber numberWithDouble:location.coordinate.longitude],
    @"ts": [dateFormatter stringFromDate:location.timestamp]
};
NSData *data = [NSJSONSerialization dataWithJSONObject:dict options:0 error:nil];
NSString *body =[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
----

This body follows the JSON format. We will add a +content-type+ header in the STOMP message and set it to +application/json; charset=utf-8+ to let the STOMP brokers and the eventual consumers know that this message's body can be read as JSON string encoded with UTF-8.
Without such a +content-type+, the consumers would not necessarily know how to _read_ the data in the body and interpret them.


[source,objc]
----
NSDictionary *headers = @{
    @"content-type": @"application/json; charset=utf-8"
};
----

We now have the +destination+, +headers+, and +body+ to send in the message.
Last step is to use the +client+'s +sendTo:headers:body+ method to do this:

[source,objc]
----
// send the message
[self.client sendTo:destination
            headers:headers
               body:body];
----

We will put all these different steps in a single method name +sendLocation:+
that takes a +CLLocation+ object:

====
[source,objc]
----
- (void)sendLocation:(CLLocation *)location
{
    // build a static NSDateFormatter to display the current date in ISO-8601
    static NSDateFormatter *dateFormatter = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        dateFormatter = [[NSDateFormatter alloc] init];
        dateFormatter.dateFormat = @"yyyy-MM-d'T'HH:mm:ssZZZZZ";
    });

    // send the message to the truck's topic
    NSString *destination = [NSString stringWithFormat:@"/topic/truck.%@.position", self.truckID];

    // build a dictionary containing all the information to send
    NSDictionary *dict = @{
        @"truck": self.truckID,
        @"lat": [NSNumber numberWithDouble:location.coordinate.latitude],
        @"lng": [NSNumber numberWithDouble:location.coordinate.longitude],
        @"ts": [dateFormatter stringFromDate:location.timestamp]
    };
    // create a JSON string from this dictionary
    NSData *data = [NSJSONSerialization dataWithJSONObject:dict options:0 error:nil];
    NSString *body =[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];

    NSDictionary *headers = @{
        @"content-type": @"application/json; charset=utf-8"
    };
    
    // send the message
    [self.client sendTo:destination
                headers:headers
                   body:body];
}
----
====

Next step is to call this method every time we receive an updated location in the +locationManager:didUpdateToLocation:fromLocation:+ method.

====
[source,objc]
----
- (void)locationManager:(CLLocationManager *)manager
    didUpdateToLocation:(CLLocation *)newLocation
           fromLocation:(CLLocation *)oldLocation
{
    // ignore if the location is older than 30s
    if (fabs([newLocation.timestamp timeIntervalSinceDate:[NSDate date]]) > 30) {
        return;
    }
    
    CLLocationCoordinate2D coord = [newLocation coordinate];
    self.currentPositionLabel.text = [NSString stringWithFormat:@"φ:%.4F, λ:%.4F", coord.latitude, coord.longitude];

    // send a message with the location data
    [self sendLocation:newLocation];
}
----
====

When we run the application, a STOMP message will be sent every time the location manager updates the device's location.

How can we check that messages are effectively sent?

We will confirm it at three different stages:

* display debug log on the device to check that messages are sent
* use ActiveMQ consoles to check that it effectively handled the sent messages
* write the simplest STOMP consumer that can receive these messages.

==== Display StompKit debug log.

Every time the StompKit library sends a message to a STOMP broker, it logs the STOMP frame that is sent.

To display them in the console, edit the file named +StompKit.m+ in Xcode that is under the +Pods+ project (its full path is +Pods+ > +Pods+ > +StompKit+ > +StompKit.m+ in the Project Navigator view) and change the macro to activate logs by replacing the +0+ by **`1`**.

[source,objc]
----
#if 1 // set to 1 to enable logs
----

If we restart the application, we now see debug statements in Xcode's Debug console:

----
2014-01-31 10:48:56.750 TruckTracker[2460:70b] >>> SEND
destination:/topic/truck.66284AB0-C266-4A4D-9443-FEFB5774FA3C.position
content-type:application/json; charset=utf-8
content-length:118

{"lng":-122.0307334,"lat":37.33154242,"ts":"2014-01-31T10:48:56+01:00","truck":"
66284AB0-C266-4A4D-9443-FEFB5774FA3C"}
...
----

This confirms that STOMP messages are effectively sent by the application.

==== ActiveMQ admin console

==== A Simple STOMP consumer

When I presented STOMP, I wrote that the protocol is so simple that a +telnet+ client _is_ a STOMP client.

Let's prove that by writing the simplest STOMP client that will consume the messages sent by the application.

We need to open a +telnet+ client to connect to the broker host on the +61613+ port. Since I am on the same machine than the broker, I will simply connect to +localhost+:

.Connection with a telnet client
====
++++
<screen>
$ <userinput>telnet localhost 61613</userinput>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
</screen>
++++
====

Once the client is connected, we must connect to the broker to open a STOMP connection (as we did in the application using +STOMPClient+'s +connectWithHeaders:completionHandler:+ method).

.Connect to a STOMP broker
====
++++
<screen>
<userinput>CONNECT

</userinput>^@
</screen>
++++
====

[CAUTION]
====
A STOMP frame must be ended by a NULL octet.

The +^@+ is the ASCII character for NULL octet. Type +ctrl + @+ to enter it.
====

Note also that there is a blank line between the +CONNECT+ line and the NULL octet. This blank line is mandatory to separate the command name and the headers from the beginning of the optional payload (that is not present in the +CONNECT+ frame).

Once you type +ctrl + @+, the messaging broker will process the +CONNECT+ frame
and reply with a +CONNECTED+ frame:

.Receive a connection confirmation
====
++++
<screen>
CONNECTED
heart-beat:0,0
session:ID:jeff.local-63055-1391518653216-2:23
server:ActiveMQ/5.9.0
version:1.2
</screen>
++++
====

The STOMP connection is now established and the telnet client can now exchange messages with the broker. We are only interested to consume messages sent by the application on the truck's position topic. 
The Truck ID is displayed on the application screen. You will have to adapt the command to use your own truck ID to receive its message.

----
SUBSCRIBE
destination:/topic/truck.66284AB0-C266-4A4D-9443-FEFB5774FA3C.position

^@
----

As soon as we sent this command to the STOMP broker, we will receive +MESSAGE+ frames that corresponds to the messages sent by the application:

----
MESSAGE
content-type:application/json; charset=utf-8
message-id:ID\cretsina.local-64018-1390843083020-2\c6\c-1\c1\c356
destination:/topic/truck.66284AB0-C266-4A4D-9443-FEFB5774FA3C.position
timestamp:1391162082774
expires:0
subscription:mysub
content-length:119
priority:4

{"lng":-122.02859586,"lat":37.33770217,"ts":"2014-01-31T10:54:42+01:00","truck":"66284AB0-C266-4A4D-9443-FEFB5774FA3C"}
----

[NOTE]
====
We can see that there are more headers in the consumed messages that in the messages we sent (which only had +content-type+ and +content-lenght+).
These headers are added by the STOMP broker and provides additional metadata about the messages. We will explore some of them later in <<ch_advanced_stomp>> and <<ch_beyond_stomp>>.
====

At this stage, we have a mobile application that is broadcasting its position by sending messages to a STOMP destination.

=== Create the orders table

We will now code the second part of the mobile applications that will receive orders for the truck and display them in a table.

Let's write the graphical part first by adding a +UITable+ to the user interface.

Click on +Main.storyboard+ to open it. From the +Object+ library, drag a +Table View+ on the View's window. Place it below the +currentPositionLable+ and make it as wide as possible.

[[img_mobile_stomp_16]]
.Add a Table View
image::images/Chapter020/table_view.png["Add a Table View"]

From the +Object+ library, drag a +Table View Cell+ inside the +Table View+.

[[img_mobile_stomp_17]]
.Add a Table View Cell
image::images/Chapter020/table_view_cell.png["Add a Table View Cell"]

We will change the +Table View Cell+ properties by setting its +Style+ to +Basic+ and its +Identifier+ to +TruckOrderCell+.

[[img_mobile_stomp_18]]
.Edit the Table View Cell Properties
image::images/Chapter020/table_view_cell_properties.png["Edit the Table View Cell Properties"]

Open the MWMViewController.m` file, make the +MWMViewController+ interface conform to the +UITableViewDataSource+ and +UITableViewDelegate+ protocols and add a property to bind the table.

====
[source, objc]
----
@interface MWMViewController () <CLLocationManagerDelegate, UITableViewDataSource, UITableViewDelegate>

@property (weak, nonatomic) IBOutlet UITableView *tableView;

@end
----
====

We then bind this property to the table. Open the **`Main.storyboard`** and control-click on +View Controller+ to see its connection panel. Drag from +tableView+ to the table to connect it.

[[img_mobile_stomp_18]]
.Connect the table view to the outlet property.
image::images/Chapter020/table_view_connection.png["Connect the table view to the outlet property."]

The table is now connected to the +tableView+ property. 

We also need to connect the +View Controller+ to the +Table View+ and declare it as it +dataSource+ and +delegate+.

Open the **`Main.storyboard`** and control-click on +Table View+ to see its connection panel. Drag from +dataSource+ to the +View Controller+ to connect it.

[[img_mobile_stomp_19]]
.Connect the view controller to the table view's dataSource.
image::images/Chapter020/table_view_dataSource_connection.png["Connect the view controller to the table view's dataSource"]

We also connect the +View Controller+ to the +Table View+'s +delegate+ property.

[[img_mobile_stomp_20]]
.Connect the view controller to the table view's dataSource.
image::images/Chapter020/table_view_delegate_connection.png["Connect the view controller to the table view's dataSource"]

The graphical objects are now bound to the properties. Next step is to make the +MWMViewController+ comply to the +UITableViewDataSource+ and +UITableViewDelegate+ protocols. 

The table will only display the orders. As there is no interaction with the table, we do not need to add any methods from the +UITableViewDelegate+ 
protocol. Let's just add a comment to the +MWMViewController+ implementation to remember it

[source, objc]
----
#pragma mark - UITableViewDelegate

// no delegate actions
----

The controller is also the +dataSource+ of the table. We will keep a list of the orders in memory in an array. Let's add a +orders+ array to the +MWMViewController+ implementation and instatiate it in its +viewDidLoad+ method.

[source, objc]
----
@implementation MWMViewController

// the orders are stored in an array of NSString.
NSMutableArray *orders;

- (void)viewDidLoad
{
    [super viewDidLoad];

    self.truckID = [UIDevice currentDevice].identifierForVendor.UUIDString;

    self.client = [[STOMPClient alloc] initWithHost:kHost port:kPort];
    
    orders = [[NSMutableArray alloc] init];
}

----

This +orders+ array will be used as the source of data for the table.
Let's implement the required +UITableViewDataSource+ methods.

[source, objc]
----
#pragma mark - UITableViewDataSource

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
    return [orders count];
}

- (UITableViewCell *)tableView:(UITableView *)tableView
         cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    // this identifier must be the same that was set in the
    // Table View Cell properties in the story board.
    static NSString *CellIdentifier = @"TruckOrderCell";
    
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
    
    cell.textLabel.text = [orders objectAtIndex:indexPath.row];
    return cell;
}
----

With these methods implemented, the table will displayed all the orders that are stored in the +orders+ array.

=== Receive Messages With STOMP

Now that we are ready to display the orders in the table, next step is to subscribe to the truck's order destination to consume STOMP messages containing the orders and put them in the +orders+ array.

To consume messages, a STOMP client must:

. connect to the broker 
. subscribe to the destination it wants to consume messages from.


==== Subscribe to a STOMP destination

We already took care of step (1) by calling +STOMPClient+'s +connectWithHeaders:completionHandler:+ in +MWMViewController+'s +connect+ method.

Step (2) is handled in STOMPKit by calling +STOMPClient+'s +subscribeTo:headers:messageHandler:+ method.

This method takes 3 parameters:

* the +destination+ that the client wants to consume from. In our case it is the destination for the truck's orders.
* a dictionary of +headers+ to pass additional metadata to the subscription. Since we do not have any such header for the time being, we will pass a empty dictionary
* a +STOMPMessageHandler+ block with a +STOMPMessage+ parameter that will be called every time the broker sends a messages to the client to consume it. In our case, we will have to create a dictionary from the JSON string contained in the message body and add the order to the +orders+ array.

We will add a method named +subscribe+ to the +MWMViewController+ implementation:

[source, objc]
----
    // susbscribes to the truck's orders queue:
    NSString *destination = [NSString stringWithFormat:@"/queue/truck.%@.orders", self.truckID];
    
    NSLog(@"subscribing to %@", destination);
    subscription = [self.client subscribeTo:destination
                                    headers:@{}
                             messageHandler:^(STOMPMessage *message) {
        // called every time a message is consumed from the orders destination
        NSLog(@"received message %@", message);
        NSData *data = [message.body dataUsingEncoding:NSUTF8StringEncoding];
        NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data
                                                             options:NSJSONReadingMutableContainers
                                                               error:nil];
        NSString *order = dict[@"order"];
        NSLog(@"adding order = %@", order);
        [orders addObject:order];
        // TODO reload the table
    }];
}
----

+subscription+ is a object returned by the +subscribe+ method that identifies the STOMP subscription and can be used to _unsubscribe_.

We declare this object in the +MWMViewController+'s implementation.

[source,objc]
----
@implementation MWMViewController

STOMPSubscription *subscription;
----

When do we call this +subscribe+ method? As soon as we are connected to the STOMP broker. We need to call it in the +connect+ method from the +completionHandler+ block that will be called when the client is _successfully_ connected to the STOMP broker:

[source,objc]
----
#pragma mark - Messaging

- (void)connect
{
    NSLog(@"Connecting...");
    [self.client connectWithHeaders:@{ @"client-id": self.truckID}
                  completionHandler:^(STOMPFrame *connectedFrame, NSError *error) {
                      if (error) {
                          // We have not been able to connect to the broker.
                          // Let's log the error
                          NSLog(@"Error during connection: %@", error);
                      } else {
                          // we are connected to the STOMP broker without an error. Now we can subscribe to the destination
                          NSLog(@"Connected");
                          [self subscribe];
                      }
                  }];
    // when the method returns, we can not assume that the client is connected
}
----

==== Unsubscribe from the destination

The application will consume messages from the destination as long as it remains connected to the STOMP broker.

We do not need to explicitly unsubscribe from the destination when we disconnect from the broker but it is a good practice to do so. To unsubscribe, we just need to call the +unsubscribe+ method on the +subscription+ object that was created when we subscribed. We will unsubscribe just prior to disconnecting from the broker in the +viewDidDisappear:+ method.


[source,objc]
----
- (void)viewDidDisappear:(BOOL)animated
{
    [self stopUpdatingCurrentLocation];
    [subscription unsubscribe];
    [self disconnect];
}
----

The application is now ready to consume messages. Let's start it and check that it is working.

Run the application in the iOS simulator or on your device.

Go to the ActiveMQ admin console and browse to the truck order's queue. In my case, its name is +truck.4A42547A-CED5-4F0B-9504-BD1496F69C25.orders+.

Fill the text area with a JSON String that conforms to the message representation we decided in <<ch_introduction_example_message>>.

----
{
  "order": "Go to warehouse #1"
}
----

[[img_mobile_stomp_21]]
.Send a Message using ActiveMQ Admin Console.
image::images/Chapter020/activemq_admin_send_message.png["Send a Message using ActiveMQ Admin Console"]

Click on the +Send Message+ button to send the message on the destination.

We see in the application log that a STOMP message has been received and that the +order+ was extracted from the message's body.

----
2014-02-04 17:41:38.062 TruckTracker[81867:3a03] received message MESSAGE
priority:0
destination:/queue/truck.4A42547A-CED5-4F0B-9504-BD1496F69C25.orders
timestamp:1391532089574
message-id:ID\cjeff.local-63055-1391518653216-62\c1\c1\c1\c1
expires:0
subscription:sub-0

{  "order": "Go to warehouse #1"}
2014-02-04 17:41:38.063 TruckTracker[81867:3a03] adding order = Go to warehouse #1
----

However, nothing is displayed in the application. We forgot to reload the table to display the received orders.

Let's fix that by calling +reloadData+ on the +tableView+ property from the +STOMPMessageHandler+ block.

[source,objc]
----
- (void)subscribe
{
    // susbscribes to the truck's orders queue:
    NSString *destination = [NSString stringWithFormat:@"/queue/truck.%@.orders", self.truckID];
    
    NSLog(@"subscribing to %@", destination);
    subscription = [self.client subscribeTo:destination
                                    headers:@{}
                             messageHandler:^(STOMPMessage *message) {
        // called every time a message is consumed from the orders destination
        NSLog(@"received message %@", message);
        NSData *data = [message.body dataUsingEncoding:NSUTF8StringEncoding];
        NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data
                                                             options:NSJSONReadingMutableContainers
                                                               error:nil];
        NSString *order = dict[@"order"];
        NSLog(@"adding order = %@", order);
        [orders addObject:order];
        dispatch_async(dispatch_get_main_queue(), ^{
            [self.tableView reloadData];
        });
    }];
}
----

Note that we did not call directly +[self.tableView reloadData];+ from the +STOMPMessageHandler+ block.

STOMPKit uses Grand-Central Dispatch global queue to handle the communication between the client and the STOMP brokers. The +STOMPMessageHandler+ block is called on that queue. However any code that deals with UIKit (such as reloading the +tableView+) _must_ be executed on the queue bound to the main thread. This is why we must wrap the +reloadData+ call into a block executed on the main queue.

If we restart the application and send another message on the truck's order queue with ActiveMQ admin console, the table will display the order as soon as it is received.

[[img_mobile_stomp_22]]
.The Received Order is Displayed in the Table.
image::images/Chapter020/received_message.png["The Received Order is Displayed in the Table"]

=== Summary

In this chapter, we learn to use +StompKit+ to send and receive STOMP messages from an iOS application.

To send a message, the application must:

. connect to the STOMP broker
. send the message to the destination

To consume a message, the application must

. connect to the STOMP broker
. subscribe to the destination and pass a block that is called every time a message is received. This block is executed on GCD global queue. If there are any code that changes the user interface, it must be wrapped in a block executed on the main queue instead.

Sending and consuming messages are only possible once the client is _successfully_ connected to the STOMP broker. Due to the event-driven design of StompKit, this is the case when the completionHandler block is executed without an error in +connectWithHeaders:completionHandler:+. 






